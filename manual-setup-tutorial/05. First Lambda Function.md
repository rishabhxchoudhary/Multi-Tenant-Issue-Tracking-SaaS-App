# ⚡ Part 5: First Lambda Function - Single Table Design

## What We'll Accomplish in This Part

By the end of this tutorial, you will:

- ✅ Understand how Lambda functions work with single-table DynamoDB design
- ✅ Create your first serverless function using the AWS Console
- ✅ Connect Lambda to our single DynamoDB table for issue management
- ✅ Implement company-aware business logic with perfect tenant isolation
- ✅ Use partition keys (PK) and sort keys (SK) for efficient queries
- ✅ Leverage Global Secondary Indexes (GSIs) for cross-entity queries
- ✅ Test your function with different company scenarios
- ✅ Add proper error handling and logging for production readiness
- ✅ See 3-5x performance improvement over multi-table approaches

**⏰ Estimated Time: 120-140 minutes**

## What is AWS Lambda? (Simple Explanation)

Think of AWS Lambda like a **magical code-running service**:

🏢 **Traditional Server Approach**:
- Buy a computer/server
- Install operating system and software  
- Keep it running 24/7 (even when no one uses it)
- Pay for the server whether it's used or not
- Handle maintenance, security updates, scaling

☁️ **AWS Lambda Approach**:
- Write your code (like a recipe)
- Upload it to AWS
- AWS runs your code only when needed
- Pay only for the milliseconds your code runs
- AWS handles everything else automatically

### Real-World Analogy

**Traditional Server**: Like owning a help desk office
- You rent the building 24/7
- Pay for electricity, staff, maintenance all the time
- Even when no issues are being reported

**Lambda Function**: Like hiring a support agent on-demand
- Agent only works when someone reports an issue
- You pay only for the time they're helping customers
- No overhead costs when no issues are being reported
- Agent brings their own desk and tools

### Why Lambda + Single-Table DynamoDB for Issue Tracking?

**🚀 Perfect Scaling**: Handles 1 issue or 1 million issues automatically
**💰 Cost Efficiency**: Pay only when code runs + optimized database costs
**🔒 Security**: Each company's request runs in isolated environment
**⚡ Speed**: Code starts in milliseconds + single-table queries are lightning fast
**🛠️ No Maintenance**: AWS manages servers, OS, scaling
**🌍 Global**: Runs close to teams worldwide for fast issue management

## Understanding Single-Table Design in Lambda Functions

### How Our Issue Tracking Lambda Uses Single-Table Design

```
🏢 Traditional Multi-Table Lambda Request Flow:
👤 User → 🌐 API → ⚡ Lambda → 📦 Table1 → 📦 Table2 → 📦 Table3 → 🔄 Join Data

Problems:
❌ Multiple database calls (slow)
❌ Complex data joining in code
❌ Higher costs (more requests)
❌ Harder to maintain consistency

🚀 Our Single-Table Lambda Request Flow:
👤 User → 🌐 API → ⚡ Lambda → 📦 SingleTable → ✅ Complete Data

Benefits:
✅ Single database call (3-5x faster)
✅ Related data comes together
✅ Lower costs (fewer requests)
✅ ACID transactions possible
```

### Single-Table Query Patterns in Lambda

**Example Journey**: User from ACME Corp clicks "View My Issues"

```python
# Traditional Multi-Table Approach (slow)
def get_user_issues_old_way(company_id, user_email):
    # Query 1: Get user info from Users table
    user = dynamodb.Table('IssueTracker-Users-Pooled').get_item(...)
    
    # Query 2: Get issues from Issues table  
    issues = dynamodb.Table('IssueTracker-Issues-Pooled').query(...)
    
    # Query 3: Get teams from Teams table
    teams = dynamodb.Table('IssueTracker-Teams-Pooled').query(...)
    
    # Query 4: Join data in Python code
    return join_data_manually(user, issues, teams)

# Our Single-Table Approach (fast)
def get_user_issues_new_way(company_id, user_email):
    # Query 1: Get user's assigned issues via GSI
    issues = table.query(
        IndexName='CrossEntityIndex',
        KeyConditionExpression=Key('GSI1PK').eq(f'USER#{user_email}')
    )
    
    # Done! All related data comes together
    return issues['Items']
```

## Step 1: Create Lambda Function Using AWS Console

### 1.1 Access Lambda Service

1. **Sign in** to AWS Console (as your IAM user)
2. **Search** for `Lambda` in the search bar
3. Click **"Lambda"** from the results
4. Click the orange **"Create function"** button

### 1.2 Configure Basic Function Settings

**Function Configuration**:
1. **Function option**: Select **"Author from scratch"**
2. **Function name**: Enter `IssueTracker-IssueManagement`
3. **Runtime**: Select **"Python 3.11"**
4. **Architecture**: Select **"x86_64"**

**Permissions**:
1. **Execution role**: Select **"Use an existing role"**
2. **Existing role**: Select `IssueTracker-Lambda-ExecutionRole`
   - If this doesn't exist, select "Create a new role with basic Lambda permissions"

3. Click **"Create function"**

⏳ **Wait for function creation** (usually takes 30-60 seconds)

### 1.3 Configure Environment Variables

1. In the Lambda function console, scroll down to **"Configuration"**
2. Click **"Environment variables"** in the left sidebar
3. Click **"Edit"**
4. Click **"Add environment variable"** for each of these:

**Required Environment Variables**:
- **Key**: `DYNAMODB_TABLE_NAME`, **Value**: `IssueTracker-SingleTable`
- **Key**: `CROSS_ENTITY_INDEX`, **Value**: `CrossEntityIndex`
- **Key**: `STATUS_TIME_INDEX`, **Value**: `StatusTimeIndex`
- **Key**: `TEAM_ASSIGNMENT_INDEX`, **Value**: `TeamAssignmentIndex`
- **Key**: `LOG_LEVEL`, **Value**: `INFO`

5. Click **"Save"**

### 1.4 Update Function Timeout

1. Click **"General configuration"** in the left sidebar
2. Click **"Edit"**
3. **Timeout**: Change from `3 sec` to `30 sec`
   - Single-table queries are fast, but we want buffer for complex operations
4. **Memory**: Leave at `128 MB` (sufficient for issue management)
5. Click **"Save"**

## Step 2: Write Single-Table Issue Management Code

### 2.1 Access Code Editor

1. Click **"Code"** tab in the Lambda function console
2. You should see the code editor with `lambda_function.py`
3. **Delete all existing code** in the editor

### 2.2 Add Complete Single-Table Lambda Code

**Paste this complete code** into the editor:

```python
import json
import boto3
import logging
from boto3.dynamodb.conditions import Key, Attr
from datetime import datetime, timezone
import uuid
import os
from decimal import Decimal

# Configure logging
logger = logging.getLogger()
logger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))

# Initialize single table connection
table_name = os.environ.get('DYNAMODB_TABLE_NAME', 'IssueTracker-SingleTable')
cross_entity_index = os.environ.get('CROSS_ENTITY_INDEX', 'CrossEntityIndex')
status_time_index = os.environ.get('STATUS_TIME_INDEX', 'StatusTimeIndex')
team_assignment_index = os.environ.get('TEAM_ASSIGNMENT_INDEX', 'TeamAssignmentIndex')

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(table_name)

def lambda_handler(event, context):
    """
    Main Lambda handler for issue management using single-table design
    
    Supported operations:
    - GET /issues - List all issues for company
    - GET /issues/user/{email} - Get issues assigned to user
    - GET /issues/team/{team_id} - Get issues assigned to team
    - GET /issues/status/{status} - Get issues by status
    - GET /issues/{id} - Get specific issue
    - POST /issues - Create new issue
    - PUT /issues/{id} - Update existing issue
    """
    
    try:
        # Extract request details
        http_method = event.get('httpMethod', '')
        path = event.get('path', '')
        path_parameters = event.get('pathParameters') or {}
        body = event.get('body', '{}')
        
        # Parse request body
        request_data = {}
        if body and body.strip():
            request_data = json.loads(body)
        
        # Extract user context for company isolation
        request_context = event.get('requestContext', {})
        authorizer = request_context.get('authorizer', {})
        
        # For testing, we'll use headers if authorizer info isn't available
        headers = event.get('headers', {})
        user_company = (authorizer.get('company_id') or 
                       headers.get('X-Company-ID', 'ACME'))
        user_email = (authorizer.get('claims', {}).get('email') or 
                     headers.get('X-User-Email', 'john@acme.com'))
        user_role = (authorizer.get('user_role') or 
                    headers.get('X-User-Role', 'User'))
        
        logger.info(f"Processing {http_method} {path} for user {user_email} from company {user_company}")
        
        # Route to appropriate handler
        if http_method == 'GET':
            return handle_get_requests(path, path_parameters, user_company, user_email, user_role)
        elif http_method == 'POST':
            return handle_post_requests(path, request_data, user_company, user_email, user_role)
        elif http_method == 'PUT':
            return handle_put_requests(path, path_parameters, request_data, user_company, user_email, user_role)
        else:
            return create_response(405, {'error': f'Method {http_method} not allowed'})
            
    except Exception as e:
        logger.error(f"Unhandled error in lambda_handler: {str(e)}")
        return create_response(500, {'error': 'Internal server error'})

def handle_get_requests(path, path_parameters, user_company, user_email, user_role):
    """Handle GET requests using single-table queries"""
    
    try:
        if path == '/issues':
            # Get all issues for company using single partition query
            return get_company_issues(user_company, user_role, user_email)
            
        elif path.startswith('/issues/user/'):
            # Get issues assigned to specific user via GSI
            target_user = path_parameters.get('email', path.split('/')[-1])
            return get_user_assigned_issues(target_user, user_company, user_role, user_email)
            
        elif path.startswith('/issues/team/'):
            # Get issues assigned to team via GSI
            team_id = path_parameters.get('team_id', path.split('/')[-1])
            return get_team_assigned_issues(team_id, user_company)
            
        elif path.startswith('/issues/status/'):
            # Get issues by status via GSI
            status = path_parameters.get('status', path.split('/')[-1])
            return get_issues_by_status(status, user_company, user_role, user_email)
            
        elif path.startswith('/issues/') and len(path.split('/')) == 3:
            # Get specific issue
            issue_id = path_parameters.get('id', path.split('/')[-1])
            return get_specific_issue(issue_id, user_company)
            
        else:
            return create_response(404, {'error': 'Endpoint not found'})
            
    except Exception as e:
        logger.error(f"Error in handle_get_requests: {str(e)}")
        return create_response(500, {'error': 'Database query failed'})

def get_company_issues(company_id, user_role, user_email):
    """Get all issues for a company using single partition query"""
    
    logger.info(f"Getting issues for company {company_id}")
    
    # Single query to get all company issues - much faster than multi-table!
    response = table.query(
        KeyConditionExpression=Key('PK').eq(f'COMPANY#{company_id}') & 
                              Key('SK').begins_with('ISSUE#'),
        ScanIndexForward=False  # Most recent first
    )
    
    issues = response.get('Items', [])
    
    # Apply role-based filtering
    if user_role == 'User':
        # Regular users only see issues they're involved with
        issues = [
            issue for issue in issues
            if (issue.get('assigned_user') == user_email or 
                issue.get('reporter') == user_email)
        ]
    # Admins and Super Admins see all company issues
    
    # Convert Decimal types for JSON serialization
    issues = convert_decimal_to_float(issues)
    
    logger.info(f"Found {len(issues)} issues for company {company_id}")
    
    return create_response(200, {
        'issues': issues,
        'total': len(issues),
        'company_id': company_id
    })

def get_user_assigned_issues(target_user, user_company, user_role, requesting_user):
    """Get issues assigned to a specific user via GSI"""
    
    # Permission check
    if target_user != requesting_user and user_role not in ['Admin', 'Super Admin']:
        return create_response(403, {'error': 'Permission denied'})
    
    logger.info(f"Getting assigned issues for user {target_user}")
    
    # Use GSI to find all issues assigned to this user
    response = table.query(
        IndexName=cross_entity_index,
        KeyConditionExpression=Key('GSI1PK').eq(f'USER#{target_user}') &
                              Key('GSI1SK').begins_with('ISSUE#')
    )
    
    issues = response.get('Items', [])
    
    # Filter to only issues from user's company
    company_issues = [
        issue for issue in issues
        if issue.get('company_id') == user_company
    ]
    
    company_issues = convert_decimal_to_float(company_issues)
    
    return create_response(200, {
        'issues': company_issues,
        'assigned_user': target_user,
        'total': len(company_issues)
    })

def get_team_assigned_issues(team_id, user_company):
    """Get issues assigned to a team via GSI"""
    
    logger.info(f"Getting assigned issues for team {team_id} in company {user_company}")
    
    # Use team assignment GSI
    response = table.query(
        IndexName=team_assignment_index,
        KeyConditionExpression=Key('GSI3PK').eq(f'TEAM#{user_company}#{team_id}') &
                              Key('GSI3SK').begins_with('ISSUE#')
    )
    
    issues = response.get('Items', [])
    issues = convert_decimal_to_float(issues)
    
    return create_response(200, {
        'issues': issues,
        'team_id': team_id,
        'company_id': user_company,
        'total': len(issues)
    })

def get_issues_by_status(status, user_company, user_role, user_email):
    """Get issues by status using status-time GSI"""
    
    logger.info(f"Getting {status} issues for company {user_company}")
    
    # Use status-time GSI for efficient filtering
    response = table.query(
        IndexName=status_time_index,
        KeyConditionExpression=Key('GSI2PK').eq(f'COMPANY#{user_company}#STATUS#{status}'),
        ScanIndexForward=False  # Most recent first
    )
    
    issues = response.get('Items', [])
    
    # Apply role-based filtering
    if user_role == 'User':
        issues = [
            issue for issue in issues
            if (issue.get('assigned_user') == user_email or 
                issue.get('reporter') == user_email)
        ]
    
    issues = convert_decimal_to_float(issues)
    
    return create_response(200, {
        'issues': issues,
        'status': status,
        'company_id': user_company,
        'total': len(issues)
    })

def get_specific_issue(issue_id, user_company):
    """Get a specific issue by ID"""
    
    logger.info(f"Getting issue {issue_id} for company {user_company}")
    
    # First get all company issues to find the one with matching ID
    response = table.query(
        KeyConditionExpression=Key('PK').eq(f'COMPANY#{user_company}') & 
                              Key('SK').begins_with('ISSUE#')
    )
    
    issues = response.get('Items', [])
    
    # Find the specific issue
    issue = next((item for item in issues if item.get('issue_id') == issue_id), None)
    
    if not issue:
        return create_response(404, {'error': f'Issue {issue_id} not found'})
    
    issue = convert_decimal_to_float(issue)
    
    return create_response(200, {'issue': issue})

def handle_post_requests(path, request_data, user_company, user_email, user_role):
    """Handle POST requests for creating entities"""
    
    try:
        if path == '/issues':
            return create_issue(request_data, user_company, user_email, user_role)
        else:
            return create_response(404, {'error': 'Endpoint not found'})
            
    except Exception as e:
        logger.error(f"Error in handle_post_requests: {str(e)}")
        return create_response(500, {'error': 'Failed to create resource'})

def create_issue(issue_data, user_company, user_email, user_role):
    """Create a new issue using single-table design"""
    
    # Validate required fields
    required_fields = ['title', 'description', 'priority', 'issue_type']
    missing_fields = [field for field in required_fields if not issue_data.get(field)]
    
    if missing_fields:
        return create_response(400, {
            'error': 'Missing required fields',
            'missing_fields': missing_fields
        })
    
    # Generate issue ID and timestamp
    issue_id = f"ISS-{str(uuid.uuid4())[:8].upper()}"
    current_time = datetime.now(timezone.utc).isoformat()
    
    # Build issue item with all GSI keys
    issue_item = {
        'PK': f'COMPANY#{user_company}',
        'SK': f'ISSUE#{issue_id}#{current_time}',
        'EntityType': 'ISSUE',
        'company_id': user_company,
        'issue_id': issue_id,
        'title': issue_data['title'],
        'description': issue_data['description'],
        'status': issue_data.get('status', 'Open'),
        'priority': issue_data['priority'],
        'issue_type': issue_data['issue_type'],
        'assigned_user': issue_data.get('assigned_user', ''),
        'assigned_team': issue_data.get('assigned_team', ''),
        'reporter': user_email,
        'created_date': current_time,
        'updated_date': current_time,
        'due_date': issue_data.get('due_date', ''),
        'labels': issue_data.get('labels', []),
        'estimated_hours': issue_data.get('estimated_hours', 0),
        'story_points': issue_data.get('story_points', 0)
    }
    
    # Add GSI keys for efficient queries
    if issue_item['assigned_user']:
        issue_item['GSI1PK'] = f"USER#{issue_item['assigned_user']}"
        issue_item['GSI1SK'] = f"ISSUE#{issue_id}"
    
    issue_item['GSI2PK'] = f"COMPANY#{user_company}#STATUS#{issue_item['status']}"
    issue_item['GSI2SK'] = current_time
    
    if issue_item['assigned_team']:
        issue_item['GSI3PK'] = f"TEAM#{user_company}#{issue_item['assigned_team']}"
        issue_item['GSI3SK'] = f"ISSUE#{issue_id}"
    
    try:
        # Write to single table
        table.put_item(Item=issue_item)
        
        logger.info(f"Created issue {issue_id} for company {user_company}")
        
        return create_response(201, {
            'message': 'Issue created successfully',
            'issue_id': issue_id,
            'issue': convert_decimal_to_float(issue_item)
        })
        
    except Exception as e:
        logger.error(f"Error creating issue: {str(e)}")
        return create_response(500, {'error': 'Failed to create issue'})

def handle_put_requests(path, path_parameters, request_data, user_company, user_email, user_role):
    """Handle PUT requests for updating entities"""
    
    try:
        if path.startswith('/issues/'):
            issue_id = path_parameters.get('id', path.split('/')[-1])
            return update_issue(issue_id, request_data, user_company, user_email, user_role)
        else:
            return create_response(404, {'error': 'Endpoint not found'})
            
    except Exception as e:
        logger.error(f"Error in handle_put_requests: {str(e)}")
        return create_response(500, {'error': 'Failed to update resource'})

def update_issue(issue_id, update_data, user_company, user_email, user_role):
    """Update an existing issue"""
    
    # First, find the issue
    response = table.query(
        KeyConditionExpression=Key('PK').eq(f'COMPANY#{user_company}') & 
                              Key('SK').begins_with('ISSUE#')
    )
    
    issues = response.get('Items', [])
    issue = next((item for item in issues if item.get('issue_id') == issue_id), None)
    
    if not issue:
        return create_response(404, {'error': f'Issue {issue_id} not found'})
    
    # Permission check
    if (user_role == 'User' and 
        issue.get('assigned_user') != user_email and 
        issue.get('reporter') != user_email):
        return create_response(403, {'error': 'Permission denied'})
    
    # Build update expression
    update_expression = "SET updated_date = :updated_date"
    expression_values = {':updated_date': datetime.now(timezone.utc).isoformat()}
    
    # Update allowed fields
    allowed_updates = ['title', 'description', 'status', 'priority', 'assigned_user', 
                      'assigned_team', 'due_date', 'labels', 'estimated_hours', 'story_points']
    
    for field in allowed_updates:
        if field in update_data:
            update_expression += f", {field} = :{field}"
            expression_values[f':{field}'] = update_data[field]
    
    # Update GSI keys if status or assignment changed
    if 'status' in update_data:
        update_expression += ", GSI2PK = :gsi2pk"
        expression_values[':gsi2pk'] = f"COMPANY#{user_company}#STATUS#{update_data['status']}"
    
    if 'assigned_user' in update_data:
        if update_data['assigned_user']:
            update_expression += ", GSI1PK = :gsi1pk, GSI1SK = :gsi1sk"
            expression_values[':gsi1pk'] = f"USER#{update_data['assigned_user']}"
            expression_values[':gsi1sk'] = f"ISSUE#{issue_id}"
        else:
            # Remove GSI keys if unassigned
            update_expression += " REMOVE GSI1PK, GSI1SK"
    
    try:
        # Update the item
        response = table.update_item(
            Key={'PK': issue['PK'], 'SK': issue['SK']},
            UpdateExpression=update_expression,
            ExpressionAttributeValues=expression_values,
            ReturnValues='ALL_NEW'
        )
        
        updated_issue = convert_decimal_to_float(response['Attributes'])
        
        logger.info(f"Updated issue {issue_id} for company {user_company}")
        
        return create_response(200, {
            'message': 'Issue updated successfully',
            'issue': updated_issue
        })
        
    except Exception as e:
        logger.error(f"Error updating issue: {str(e)}")
        return create_response(500, {'error': 'Failed to update issue'})

def convert_decimal_to_float(obj):
    """Convert Decimal objects to float for JSON serialization"""
    if isinstance(obj, list):
        return [convert_decimal_to_float(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: convert_decimal_to_float(value) for key, value in obj.items()}
    elif isinstance(obj, Decimal):
        return float(obj)
    else:
        return obj

def create_response(status_code, body):
    """Create standardized HTTP response"""
    return {
        'statusCode': status_code,
        'headers': {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Company-ID,X-User-Email,X-User-Role',
            'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
        },
        'body': json.dumps(body)
    }
```

### 2.3 Deploy the Code

1. Click **"Deploy"** button (orange button in the code editor)
2. Wait for deployment to complete (usually 10-30 seconds)
3. You should see "Successfully updated the function IssueTracker-IssueManagement"

## Step 3: Test the Lambda Function

### 3.1 Create Test Event for Getting Issues

1. Click **"Test"** tab in the Lambda console
2. Click **"Create new event"**
3. **Event name**: `get-company-issues`
4. **Template**: Select **"API Gateway AWS Proxy"**
5. **Replace the template JSON** with this test event:

```json
{
  "httpMethod": "GET",
  "path": "/issues",
  "pathParameters": null,
  "headers": {
    "X-Company-ID": "ACME",
    "X-User-Email": "john@acme.com",
    "X-User-Role": "Admin"
  },
  "body": null,
  "requestContext": {
    "authorizer": {}
  }
}
```

6. Click **"Save"**
7. Click **"Test"**

✅ **Expected Result**: You should see a successful response with Acme Corp's issues from your sample data.

### 3.2 Test Creating a New Issue

1. Click **"Create new event"**
2. **Event name**: `create-issue`
3. **Template**: Select **"API Gateway AWS Proxy"**
4. **Replace the JSON** with:

```json
{
  "httpMethod": "POST",
  "path": "/issues",
  "pathParameters": null,
  "headers": {
    "X-Company-ID": "ACME",
    "X-User-Email": "john@acme.com",
    "X-User-Role": "Admin"
  },
  "body": "{\"title\": \"Test Issue from Lambda\", \"description\": \"This is a test issue created through our Lambda function\", \"priority\": \"Medium\", \"issue_type\": \"Bug\", \"assigned_user\": \"john@acme.com\", \"assigned_team\": \"BACKEND\"}",
  "requestContext": {
    "authorizer": {}
  }
}
```

5. Click **"Save"**
6. Click **"Test"**

✅ **Expected Result**: You should see a successful response with the newly created issue ID.

### 3.3 Test User-Specific Issues (GSI Query)

1. Click **"Create new event"**
2. **Event name**: `get-user-issues`
3. **Replace the JSON** with:

```json
{
  "httpMethod": "GET",
  "path": "/issues/user/john@acme.com",
  "pathParameters": {
    "email": "john@acme.com"
  },
  "headers": {
    "X-Company-ID": "ACME",
    "X-User-Email": "john@acme.com",
    "X-User-Role": "Admin"
  },
  "body": null,
  "requestContext": {
    "authorizer": {}
  }
}
```

4. Click **"Save"**
5. Click **"Test"**

✅ **Expected Result**: You should see all issues assigned to john@acme.com (demonstrates GSI query working).

### 3.4 Test Issues by Status (Another GSI Query)

1. Click **"Create new event"**
2. **Event name**: `get-issues-by-status`
3. **Replace the JSON** with:

```json
{
  "httpMethod": "GET",
  "path": "/issues/status/Open",
  "pathParameters": {
    "status": "Open"
  },
  "headers": {
    "X-Company-ID": "BETA",
    "X-User-Email": "mike@betatech.com",
    "X-User-Role": "User"
  },
  "body": null,
  "requestContext": {
    "authorizer": {}
  }
}
```

4. Click **"Save"**
5. Click **"Test"**

✅ **Expected Result**: You should see Beta Tech's open issues (demonstrates company isolation working).

## Step 4: Monitor and Debug Lambda Function

### 4.1 View CloudWatch Logs

1. Click **"Monitor"** tab in Lambda console
2. Click **"View CloudWatch logs"**
3. Click on the most recent log stream
4. You should see detailed logs of your test executions

**What to Look For**:
- ✅ "Processing GET /issues for user john@acme.com from company ACME"
- ✅ "Getting issues for company ACME"
- ✅ "Found X issues for company ACME"
- ❌ Any error messages or stack traces

### 4.2 Check DynamoDB for New Data

1. Go to **DynamoDB Console** → **Tables** → **IssueTracker-SingleTable**
2. Click **"Explore table items"**
3. Look for new issues created by your Lambda tests
4. Verify that GSI keys are properly set (GSI1PK, GSI2P