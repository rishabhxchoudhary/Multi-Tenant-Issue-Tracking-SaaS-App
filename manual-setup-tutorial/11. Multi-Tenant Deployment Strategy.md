# 🚀 Part 11: Multi-Tenant Deployment Strategy

## What We'll Accomplish in This Part

By the end of this tutorial, you will:
- ✅ Understand different deployment strategies for multi-tenant SaaS
- ✅ Learn how to update shared resources vs dedicated tenant resources
- ✅ Implement rolling updates for different subscription tiers
- ✅ Set up blue-green deployments for zero-downtime updates
- ✅ Create tenant-specific deployment pipelines
- ✅ Build automated testing before production deployments
- ✅ Implement rollback strategies for failed deployments
- ✅ Monitor deployments across all tenant tiers
- ✅ Handle database schema changes across tenants
- ✅ Coordinate updates between shared and dedicated resources

**⏰ Estimated Time: 120-140 minutes**

## What is Multi-Tenant Deployment? (Simple Explanation)

Think of multi-tenant deployment like **updating software in a school district**:

🏫 **Single School (Single Tenant)**:
- Update one school's computer lab
- If something breaks, only that school is affected
- Simple to test and rollback
- Easy to coordinate with one principal

🏢 **School District (Multi-Tenant)**:
- **Shared Resources**: District-wide systems (email, gradebook servers)
- **School-Specific**: Each school's individual computer labs
- **Premium Schools**: Have their own dedicated IT staff and servers
- **Basic Schools**: Share district IT resources and servers

### Real-World Multi-Tenant Deployment Examples

**🎯 Atlassian (Jira) Deployment Strategy**:
- **Cloud Shared**: Most customers share infrastructure, get updates automatically
- **Premium Cloud**: Dedicated instances with scheduled update windows
- **Server/Data Center**: Enterprise customers control their own update timing
- **Updates Roll Out**: Shared → Premium → Enterprise over several weeks

**📋 Salesforce Deployment Approach**:
- **Multi-Tenant Shared**: Updates deployed to shared infrastructure first
- **Dedicated Instances**: High-value customers get individual update schedules
- **Sandbox Testing**: All customers can test updates before they go live
- **Gradual Rollout**: 1% → 10% → 50% → 100% of customers over time

**🚀 GitHub Enterprise Deployment**:
- **GitHub.com**: Shared platform gets continuous updates
- **GitHub Enterprise Cloud**: Dedicated instances with coordinated updates
- **GitHub Enterprise Server**: Self-hosted, customer-controlled updates
- **Feature Flags**: New features rolled out gradually to different customer tiers

## Understanding Our Multi-Tenant Architecture

### 11.1 Tenant Resource Architecture

```
🏗️ Issue Tracking SaaS Deployment Architecture:

📦 BASIC TIER (Shared Resources):
├── Shared Lambda Functions
│   ├── SaaS-IssueManagement (handles all Basic companies)
│   ├── SaaS-TeamManagement (serves multiple companies)
│   └── SaaS-UserManagement (shared across tenants)
├── Shared DynamoDB Tables
│   ├── SaaS-Issues-Pooled (company_id partitioning)
│   ├── SaaS-Teams-Pooled (company isolation via keys)
│   └── SaaS-Users-Pooled (multi-tenant data)
└── Shared API Gateway (single endpoint for all)

💼 PREMIUM TIER (Semi-Dedicated Resources):
├── Shared Lambda Functions (higher memory allocation)
├── Dedicated DynamoDB Tables (better performance)
├── Priority API Gateway routing
└── Enhanced monitoring and alerting

🏆 PLATINUM TIER (Dedicated Resources):
├── Dedicated Lambda Functions
│   ├── CompanyABC-IssueManagement
│   ├── CompanyABC-TeamManagement
│   └── CompanyABC-UserManagement
├── Dedicated DynamoDB Tables
│   ├── CompanyABC-Issues
│   ├── CompanyABC-Teams
│   └── CompanyABC-Users
├── Dedicated API Gateway
├── Custom VPC and Security Groups
├── Dedicated Monitoring Dashboards
└── White-label Custom Domains
```

### 11.2 Deployment Complexity by Tier

```
🎯 Deployment Complexity Matrix:

BASIC TIER Updates:
├── Complexity: LOW ⭐
├── Shared Lambda update affects ALL Basic customers
├── Single deployment updates 1000+ companies
├── Risk: High (affects many customers)
├── Testing: Staging environment with sample data
└── Rollback: Single rollback affects all Basic customers

PREMIUM TIER Updates:
├── Complexity: MEDIUM ⭐⭐
├── Semi-dedicated resources need coordinated updates
├── Batch deployments by customer groups
├── Risk: Medium (affects customer groups)
├── Testing: Customer-specific staging environments
└── Rollback: Group rollbacks possible

PLATINUM TIER Updates:
├── Complexity: HIGH ⭐⭐⭐
├── Each customer has dedicated infrastructure
├── Individual deployment per customer
├── Risk: Low (isolated customer impact)
├── Testing: Full customer environment replication
└── Rollback: Individual customer rollbacks
```

## Step 1: Set Up Multi-Tier Deployment Pipeline

### 1.1 Create Deployment Configuration

Create `deployment-config.yaml`:

```yaml
# Multi-Tenant Deployment Configuration
deployment_strategy:
  name: "Issue Tracker Multi-Tenant Deployment"
  version: "1.0"
  
# Environment definitions
environments:
  development:
    description: "Development environment for testing"
    shared_resources: true
    tenant_isolation: false
    
  staging:
    description: "Staging environment mimicking production"
    shared_resources: true
    tenant_isolation: true
    test_tenants:
      - "comp_staging_basic_001"
      - "comp_staging_premium_001" 
      - "comp_staging_platinum_001"
      
  production:
    description: "Production environment with real customers"
    shared_resources: true
    tenant_isolation: true
    deployment_strategy: "rolling"

# Tenant tier configurations
tenant_tiers:
  basic:
    deployment_type: "shared"
    resource_sharing: true
    update_window: "automatic"
    rollback_strategy: "immediate"
    max_downtime_minutes: 5
    resources:
      lambda_functions:
        - "SaaS-IssueManagement"
        - "SaaS-TeamManagement"
        - "SaaS-UserManagement"
      databases:
        - "SaaS-Issues-Pooled"
        - "SaaS-Teams-Pooled"
        - "SaaS-Users-Pooled"
      api_gateway: "shared-api-gateway"
      
  premium:
    deployment_type: "semi_dedicated"
    resource_sharing: false
    update_window: "scheduled"
    rollback_strategy: "coordinated"
    max_downtime_minutes: 2
    resources:
      lambda_functions:
        - "SaaS-Premium-IssueManagement"
        - "SaaS-Premium-TeamManagement"
      databases:
        - "SaaS-Premium-Issues"
        - "SaaS-Premium-Teams"
      api_gateway: "premium-api-gateway"
      
  platinum:
    deployment_type: "dedicated"
    resource_sharing: false
    update_window: "customer_controlled"
    rollback_strategy: "individual"
    max_downtime_minutes: 0
    resources:
      lambda_functions:
        - "{company_id}-IssueManagement"
        - "{company_id}-TeamManagement"
        - "{company_id}-UserManagement"
      databases:
        - "{company_id}-Issues"
        - "{company_id}-Teams" 
        - "{company_id}-Users"
      api_gateway: "{company_id}-api-gateway"
      vpc: "{company_id}-vpc"

# Deployment phases
deployment_phases:
  phase_1_development:
    description: "Deploy to development environment"
    environments: ["development"]
    success_criteria:
      - "All unit tests pass"
      - "Integration tests pass"
      - "Performance tests under 500ms"
    
  phase_2_staging:
    description: "Deploy to staging with test tenants"
    environments: ["staging"]
    success_criteria:
      - "All staging tests pass"
      - "Test tenant workflows complete successfully"
      - "No data corruption detected"
    
  phase_3_production_basic:
    description: "Deploy to Basic tier production"
    environments: ["production"]
    tenant_tiers: ["basic"]
    deployment_strategy: "rolling"
    success_criteria:
      - "Error rate < 0.1%"
      - "Response time < 200ms"
      - "Zero data loss"
    
  phase_4_production_premium:
    description: "Deploy to Premium tier production"
    environments: ["production"]
    tenant_tiers: ["premium"]
    deployment_strategy: "blue_green"
    success_criteria:
      - "Error rate < 0.01%"
      - "Response time < 100ms"
      - "Zero downtime"
    
  phase_5_production_platinum:
    description: "Deploy to Platinum tier production"
    environments: ["production"]
    tenant_tiers: ["platinum"]
    deployment_strategy: "individual"
    success_criteria:
      - "Customer approval required"
      - "Zero error tolerance"
      - "Complete rollback capability"
```

### 1.2 Create Deployment Scripts

Create `scripts/deploy-multi-tenant.py`:

```python
#!/usr/bin/env python3
"""
🚀 Multi-Tenant Deployment Script for Issue Tracking SaaS

Like organizing a district-wide software update:
1. Start with development testing
2. Test in staging with sample schools
3. Roll out to basic schools (shared resources)
4. Update premium schools (dedicated resources)
5. Coordinate with platinum schools (individual updates)
"""

import boto3
import json
import time
import yaml
from datetime import datetime, timezone
from typing import Dict, List, Any
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MultiTenantDeploymentManager:
    """Manages deployments across different tenant tiers"""
    
    def __init__(self, config_file: str = "deployment-config.yaml"):
        with open(config_file, 'r') as f:
            self.config = yaml.safe_load(f)
        
        # Initialize AWS clients
        self.lambda_client = boto3.client('lambda')
        self.dynamodb = boto3.resource('dynamodb')
        self.apigateway = boto3.client('apigateway')
        self.cloudwatch = boto3.client('cloudwatch')
        
        logger.info("🚀 Multi-Tenant Deployment Manager initialized")
    
    def deploy_to_environment(self, environment: str, version: str):
        """Deploy to a specific environment"""
        logger.info(f"🌍 Starting deployment to {environment} environment")
        
        env_config = self.config['environments'][environment]
        
        if environment == 'development':
            return self._deploy_development(version)
        elif environment == 'staging':
            return self._deploy_staging(version)
        elif environment == 'production':
            return self._deploy_production(version)
        else:
            raise ValueError(f"Unknown environment: {environment}")
    
    def _deploy_development(self, version: str) -> bool:
        """
        🔧 Deploy to Development Environment
        
        Like testing new software in the IT department before
        rolling out to any schools:
        - Quick deployment with minimal safety checks
        - Focus on functionality validation
        - Easy rollback if issues found
        """
        logger.info("🔧 Deploying to development environment")
        
        try:
            # Deploy shared Lambda functions
            shared_functions = [
                'SaaS-IssueManagement-Dev',
                'SaaS-TeamManagement-Dev',
                'SaaS-UserManagement-Dev'
            ]
            
            for function_name in shared_functions:
                self._update_lambda_function(function_name, version)
                logger.info(f"✅ Updated {function_name}")
            
            # Run basic health checks
            if self._run_health_checks('development'):
                logger.info("✅ Development deployment successful")
                return True
            else:
                logger.error("❌ Development deployment health checks failed")
                return False
                
        except Exception as e:
            logger.error(f"❌ Development deployment failed: {e}")
            return False
    
    def _deploy_staging(self, version: str) -> bool:
        """
        🧪 Deploy to Staging Environment
        
        Like testing in a sample school before district rollout:
        - Deploy to environment that mirrors production
        - Test with sample tenant data
        - Validate all tenant tiers work correctly
        """
        logger.info("🧪 Deploying to staging environment")
        
        try:
            # Deploy to staging mirrors production setup
            staging_config = self.config['environments']['staging']
            test_tenants = staging_config['test_tenants']
            
            # Deploy shared resources first
            self._deploy_shared_resources('staging', version)
            
            # Test each tenant tier
            for tenant_id in test_tenants:
                if not self._test_tenant_functionality(tenant_id, version):
                    logger.error(f"❌ Staging test failed for tenant {tenant_id}")
                    return False
                logger.info(f"✅ Tenant {tenant_id} staging test passed")
            
            logger.info("✅ Staging deployment successful")
            return True
            
        except Exception as e:
            logger.error(f"❌ Staging deployment failed: {e}")
            return False
    
    def _deploy_production(self, version: str) -> bool:
        """
        🏭 Deploy to Production Environment
        
        Like rolling out updates across the entire school district:
        - Careful, phased deployment approach
        - Monitor each phase before proceeding
        - Different strategies for different tier customers
        """
        logger.info("🏭 Starting production deployment")
        
        try:
            # Phase 1: Deploy to Basic tier (shared resources)
            if not self._deploy_basic_tier(version):
                logger.error("❌ Basic tier deployment failed")
                return False
            
            # Phase 2: Deploy to Premium tier (semi-dedicated)
            if not self._deploy_premium_tier(version):
                logger.error("❌ Premium tier deployment failed")
                self._rollback_basic_tier()  # Rollback if needed
                return False
            
            # Phase 3: Deploy to Platinum tier (dedicated resources)
            if not self._deploy_platinum_tier(version):
                logger.error("❌ Platinum tier deployment failed")
                # Individual rollbacks for Platinum customers
                return False
            
            logger.info("🎉 Production deployment completed successfully")
            return True
            
        except Exception as e:
            logger.error(f"❌ Production deployment failed: {e}")
            return False
    
    def _deploy_basic_tier(self, version: str) -> bool:
        """
        📦 Deploy to Basic Tier (Shared Resources)
        
        Like updating the shared district computer lab software:
        - One update affects ALL basic tier customers
        - High impact but efficient deployment
        - Requires careful testing and monitoring
        """
        logger.info("📦 Deploying to Basic tier (shared resources)")
        
        try:
            basic_config = self.config['tenant_tiers']['basic']
            shared_functions = basic_config['resources']['lambda_functions']
            
            # Rolling deployment for shared Lambda functions
            for function_name in shared_functions:
                # Deploy with alias for gradual rollout
                if not self._rolling_lambda_update(function_name, version):
                    logger.error(f"❌ Failed to update {function_name}")
                    return False
                
                # Monitor for 5 minutes after each function update
                if not self._monitor_function_health(function_name, duration_minutes=5):
                    logger.error(f"❌ Health check failed for {function_name}")
                    self._rollback_lambda_function(function_name)
                    return False
                
                logger.info(f"✅ Successfully deployed {function_name}")
            
            # Update shared database schemas if needed
            shared_tables = basic_config['resources']['databases']
            for table_name in shared_tables:
                if not self._update_table_schema(table_name, version):
                    logger.warning(f"⚠️ Schema update not needed for {table_name}")
            
            logger.info("✅ Basic tier deployment completed")
            return True
            
        except Exception as e:
            logger.error(f"❌ Basic tier deployment failed: {e}")
            return False
    
    def _deploy_premium_tier(self, version: str) -> bool:
        """
        💼 Deploy to Premium Tier (Semi-Dedicated Resources)
        
        Like updating specialized labs in premium schools:
        - Each premium customer group has dedicated resources
        - Blue-green deployment for zero downtime
        - Coordinated updates across customer groups
        """
        logger.info("💼 Deploying to Premium tier (semi-dedicated resources)")
        
        try:
            # Get list of Premium tier customers
            premium_customers = self._get_customers_by_tier('premium')
            
            # Group customers for batch deployment
            customer_batches = self._create_customer_batches(premium_customers, batch_size=5)
            
            for batch_num, customer_batch in enumerate(customer_batches):
                logger.info(f"📦 Deploying batch {batch_num + 1}/{len(customer_batches)}")
                
                # Blue-green deployment for this batch
                if not self._blue_green_deployment(customer_batch, version):
                    logger.error(f"❌ Batch {batch_num + 1} deployment failed")
                    return False
                
                logger.info(f"✅ Batch {batch_num + 1} deployed successfully")
                
                # Wait between batches for monitoring
                time.sleep(300)  # 5 minutes between batches
            
            logger.info("✅ Premium tier deployment completed")
            return True
            
        except Exception as e:
            logger.error(f"❌ Premium tier deployment failed: {e}")
            return False
    
    def _deploy_platinum_tier(self, version: str) -> bool:
        """
        🏆 Deploy to Platinum Tier (Dedicated Resources)
        
        Like coordinating individual updates with premium private schools:
        - Each customer has completely dedicated infrastructure  
        - Individual deployment scheduling and approval
        - Custom deployment windows and rollback procedures
        """
        logger.info("🏆 Deploying to Platinum tier (dedicated resources)")
        
        try:
            # Get all Platinum tier customers
            platinum_customers = self._get_customers_by_tier('platinum')
            
            deployment_results = []
            
            for customer in platinum_customers:
                company_id = customer['company_id']
                company_name = customer['company_name']
                
                logger.info(f"🎯 Deploying to {company_name} ({company_id})")
                
                # Check if customer has approved this deployment
                if not customer.get('deployment_approved', False):
                    logger.info(f"⏳ Waiting for approval from {company_name}")
                    continue
                
                # Individual deployment for this customer
                deployment_result = self._individual_customer_deployment(
                    company_id, version, customer.get('deployment_window')
                )
                
                deployment_results.append({
                    'company_id': company_id,
                    'company_name': company_name,
                    'success': deployment_result,
                    'deployment_time': datetime.now(timezone.utc)
                })
                
                if deployment_result:
                    logger.info(f"✅ {company_name} deployment successful")
                else:
                    logger.error(f"❌ {company_name} deployment failed")
                    # Continue with other customers (individual isolation)
            
            # Summary of Platinum deployments
            successful_deployments = len([r for r in deployment_results if r['success']])
            total_deployments = len(deployment_results)
            
            logger.info(f"🏆 Platinum tier deployments: {successful_deployments}/{total_deployments} successful")
            
            return successful_deployments > 0  # Success if at least one customer deployed
            
        except Exception as e:
            logger.error(f"❌ Platinum tier deployment failed: {e}")
            return False
    
    def _individual_customer_deployment(self, company_id: str, version: str, deployment_window: str = None) -> bool:
        """Deploy to individual Platinum customer's dedicated resources"""
        
        try:
            # Get customer's dedicated resource names
            dedicated_resources = self._get_customer_resources(company_id)
            
            # Deploy Lambda functions
            for function_name in dedicated_resources['lambda_functions']:
                actual_function_name = function_name.replace('{company_id}', company_id)
                
                if not self._update_lambda_function(actual_function_name, version):
                    return False
            
            # Update customer's dedicated databases
            for table_name in dedicated_resources['databases']:
                actual_table_name = table_name.replace('{company_id}', company_id)
                
                if not self._update_table_schema(actual_table_name, version):
                    logger.warning(f"Schema update not needed for {actual_table_name}")
            
            # Update customer's API Gateway
            api_gateway_name = dedicated_resources['api_gateway'].replace('{company_id}', company_id)
            if not self._update_api_gateway(api_gateway_name, version):
                return False
            
            # Run customer-specific health checks
            if not self._run_customer_health_checks(company_id):
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"❌ Individual deployment failed for {company_id}: {e}")
            return False
    
    # Helper methods
    
    def _update_lambda_function(self, function_name: str, version: str) -> bool:
        """Update a specific Lambda function"""
        try:
            # This would update the Lambda function code
            logger.info(f"🔄 Updating Lambda function {function_name} to version {version}")
            
            # In a real implementation, this would:
            # 1. Upload new code to Lambda
            # 2. Update function configuration
            # 3. Create new version/alias
            
            return True
        except Exception as e:
            logger.error(f"❌ Failed to update Lambda function {function_name}: {e}")
            return False
    
    def _rolling_lambda_update(self, function_name: str, version: str) -> bool:
        """Perform rolling update of Lambda function using aliases"""
        try:
            logger.info(f"🔄 Rolling update for {function_name}")
            
            # Create new version
            # Update alias to gradually shift traffic: 10% → 50% → 100%
            # Monitor error rates at each step
            
            return True
        except Exception as e:
            logger.error(f"❌ Rolling update failed for {function_name}: {e}")
            return False
    
    def _blue_green_deployment(self, customer_batch: List[str], version: str) -> bool:
        """Perform blue-green deployment for customer batch"""
        try:
            logger.info(f"🔵🟢 Blue-green deployment for batch of {len(customer_batch)} customers")
            
            # Create "green" environment with new version
            # Test green environment
            # Switch traffic from "blue" to "green"
            # Keep blue environment for quick rollback
            
            return True
        except Exception as e:
            logger.error(f"❌ Blue-green deployment failed: {e}")
            return False
    
    def _monitor_function_health(self, function_name: str, duration_minutes: int = 5) -> bool:
        """Monitor Lambda function health after deployment"""
        try:
            logger.info(f"🏥 Monitoring {function_name} for {duration_minutes} minutes")
            
            # Monitor CloudWatch metrics:
            # - Error rate
            # - Duration
            # - Throttles
            # - Concurrent executions
            
            # For demo, simulate monitoring
            time.sleep(10)  # In real implementation, this would be actual monitoring
            
            return True
        except Exception as e:
            logger.error(f"❌ Health monitoring failed for {function_name}: {e}")
            return False
    
    def _run_health_checks(self, environment: str) -> bool:
        """Run health checks for an environment"""
        try:
            logger.info(f"🏥 Running health checks for {environment}")
            
            # Test API endpoints
            # Check database connectivity
            # Validate authentication flows
            # Test core issue tracking workflows
            
            return True
        except Exception as e:
            logger.error(f"❌ Health checks failed for {environment}: {e}")
            return False
    
    def _get_customers_by_tier(self, tier: str) -> List[Dict[str, Any]]:
        """Get list of customers by subscription tier"""
        # In real implementation, this would query DynamoDB
        if tier == 'premium':
            return [
                {'company_id': 'comp_premium_001', 'company_name': 'TechCorp Solutions'},
                {'company_id': 'comp_premium_002', 'company_name': 'Innovation Labs'}
            ]
        elif tier == 'platinum':
            return [
                {
                    'company_id': 'comp_platinum_001', 
                    'company_name': 'Enterprise Mega Corp',
                    'deployment_approved': True,
                    'deployment_window': 'weekends'
                },
                {
                    'company_id': 'comp_platinum_002', 
                    'company_name': 'Global Tech Giant',
                    'deployment_approved': False,  # Waiting for approval
                    'deployment_window': 'maintenance_window'
                }
            ]
        return []


def main():
    """Main deployment orchestration"""
    deployment_manager = MultiTenantDeploymentManager()
    
    version = f"v{datetime.now().strftime('%Y.%m.%d.%H%M')}"
    
    print(f"🚀 Starting multi-tenant deployment for version {version}")
    
    # Step 1: Development deployment
    if not deployment_manager.deploy_to_environment('development', version):
        print("❌ Development deployment failed - stopping pipeline")
        return False
    
    # Step 2: Staging deployment
    if not deployment_manager.deploy_to_environment('staging', version):
        print("❌ Staging deployment failed - stopping pipeline")
        return False
    
    # Step 3: Production deployment
    if not deployment_manager.deploy_to_environment('production', version):
        print("❌ Production deployment failed")
        return False
    
    print(f"🎉 Multi-tenant deployment {version} completed successfully!")
    return True


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)
```

## Step 2: Implement Database Schema Migration Strategy

### 2.1 Create Schema Migration Management

Create `scripts/schema-migration.py`:

```python
"""
🗄️ Multi-Tenant Database Schema Migration

Like updating the format of gradebooks across all schools:
- Some schools share the same gradebook system (Basic tier)
- Some schools have their own systems (Platinum tier)
- Updates must be coordinated and reversible
"""

import boto3
import json
from datetime import datetime, timezone
from typing import Dict, List, Any

class MultiTenantSchemaMigration:
    """Manages database schema changes across tenant tiers"""
    
    def __init__(self):
        self.dynamodb = boto3.resource('dynamodb')
        self.dynamodb_client = boto3.client('dynamodb')
    
    def migrate_all_tenants(self, migration_name: str, migration_scripts: Dict[str, Any]):
        """
        Execute schema migration across all tenant tiers
        
        Like updating gradebook format across entire school district:
        1. Start with shared tables (Basic tier)
        2. Update semi-dedicated tables (Premium tier)  
        3. Coordinate individual updates (Platinum tier)
        """
        
        print(f"🗄️ Starting schema migration: {migration_name}")
        
        results = {
            'migration_name': migration_name,
            'started_at': datetime.now(timezone.utc),
            'basic_tier': None,
            'premium_tier': None,
            'platinum_tier': None
        }
        
        try:
            # Step 1: Migrate Basic tier (shared tables)
            print("📦 Migrating Basic tier shared tables...")
            results['basic_tier'] = self._migrate_basic_tier_tables(migration_scripts)
            
            if not results['basic_tier']['success']:
                print("❌ Basic tier migration failed - stopping")
                return results
            
            # Step 2: Migrate Premium tier (semi-dedicated tables)
            print("💼 Migrating Premium tier tables...")
            results['premium_tier'] = self._migrate_premium_tier_tables(migration_scripts)
            
            # Step 3: Migrate Platinum tier (dedicated tables)
            print("🏆 Migrating Platinum tier dedicated tables...")
            results['platinum_tier'] = self._migrate_platinum_tier_tables(migration_scripts)
            
            results['completed_at'] = datetime.now(timezone.utc)
            print(f"✅ Schema migration {migration_name} completed successfully!")
            
        except Exception as e:
            print(f"❌ Schema migration failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def _migrate_basic_tier_tables(self, migration_scripts: Dict[str, Any]) -> Dict[str, Any]:
        """
        Migrate shared tables used by Basic tier customers
        
        ⚠️ HIGH RISK: Changes affect ALL Basic customers simultaneously
        """
        
        shared_tables = [
            'SaaS-Issues-Pooled',
            'SaaS-Teams-Pooled', 
            'SaaS-Users-Pooled',
            'SaaS-Comments-Pooled'
        ]
        
        migration_results = {
            'success': True,
            'tables_migrated': [],
            'tables_failed': [],
            'rollback_info': []
        }
        
        for table_name in shared_tables:
            try:
                print(f"🔄 Migrating shared table: {table_name}")
                
                # Backup current schema
                backup_info = self._backup_table_schema(table_name)
                migration_results['rollback_info'].append(backup_info)
                
                # Apply migration
                if self._apply_table_migration(table_name, migration_scripts):
                    migration_results['tables_migrated'].append(table_name)
                    print(f"✅ {table_name} migrated successfully")
                else:
                    migration_results['tables_failed'].append(table_name)
                    migration_results['success'] = False
                    print(f"❌ {table_name} migration failed")
                    
            except Exception as e:
                print(f"❌ Error migrating {table_name}: {e}")
                migration_results['tables_failed'].append(table_name)
                migration_results['success'] = False
        
        return migration_results
    
    def _migrate_premium_tier_tables(self, migration_scripts: Dict[str, Any]) -> Dict[str, Any]:
        """
        Migrate Premium tier tables (semi-dedicated per customer group)
        
        🔵 MEDIUM RISK: Changes affect customer groups
        """
        
        # Get Premium tier customer groups
        premium_customers = self._get_premium_customers()
        
        migration_results = {
            'success': True,
            'customer_groups_migrated': [],
            'customer_groups_failed': []
        }
        
        for customer_group in premium_customers:
            group_tables = self._get_premium_tables_for_group(customer_group)
            
            for table_name in group_tables:
                try:
                    if self._apply_table_migration(table_name, migration_scripts):
                        migration_results['customer_groups_migrated'].append(customer_group)
                    else:
                        migration_results['customer_groups_failed'].append(customer_group)
                        migration_results['success'] = False
                        
                except Exception as e:
                    print(f"❌ Error migrating Premium group {customer_group}: {e}")
                    migration_results['customer_groups_failed'].append(customer_group)
                    migration_results['success'] = False
        
        return migration_results
    
    def _migrate_platinum_tier_tables(self, migration_scripts: Dict[str, Any]) -> Dict[str, Any]:
        """
        Migrate Platinum tier dedicated tables (one per customer)
        
        🟢 LOW RISK: Individual customer isolation
        """
        
        platinum_customers = self._get_platinum_customers()
        
        migration_results = {
            'success': True,
            'customers_migrated': [],
            'customers_failed': []
        }
        
        for customer in platinum_customers:
            company_id = customer['company_id']
            dedicated_tables = self._get_dedicated_tables_for_customer(company_id)
            
            customer_success = True
            for table_name in dedicated_tables:
                try:
                    if not self._apply_table_migration(table_name, migration_scripts):
                        customer_success = False
                        break
                        
                except Exception as e:
                    print(f"❌ Error migrating {company_id} table {table_name}: {e}")
                    customer_success = False
                    break
            
            if customer_success:
                migration_results['customers_migrated'].append(company_id)
            else:
                migration_results['customers_failed'].append(company_id)
                # Don't fail entire migration for individual customer issues
        
        return migration_results


## Step 3: Monitoring and Rollback Strategies

### 3.1 Create Deployment Monitoring System

Create `monitoring/deployment-monitor.py`:

```python
"""
📊 Multi-Tenant Deployment Monitoring

Like having a dashboard to monitor the school district update:
- Track success/failure across all schools
- Monitor performance during rollout
- Alert if issues are detected
- Provide rollback capabilities
"""

import boto3
import json
import time
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Any
import threading

class DeploymentMonitor:
    """Monitor deployments across all tenant tiers"""
    
    def __init__(self):
        self.cloudwatch = boto3.client('cloudwatch')
        self.lambda_client = boto3.client('lambda')
        self.dynamodb = boto3.resource('dynamodb')
        
        self.monitoring_active = False
        self.alerts_triggered = []
    
    def monitor_deployment(self, deployment_info: Dict[str, Any], duration_minutes: int = 30):
        """
        🏥 Monitor deployment health across all tiers
        
        Like having nurses check on students after vaccination:
        - Monitor error rates
        - Track response times
        - Watch for unusual patterns
        - Alert if intervention needed
        """
        
        print(f"📊 Starting deployment monitoring for {duration_minutes} minutes")
        
        self.monitoring_active = True
        monitoring_results = {
            'deployment_info': deployment_info,
            'monitoring_start': datetime.now(timezone.utc),
            'alerts': [],
            'metrics': {},
            'overall_health': 'healthy'
        }
        
        try:
            # Monitor different aspects in parallel
            monitors = [
                threading.Thread(target=self._monitor_error_rates, args=(monitoring_results,)),
                threading.Thread(target=self._monitor_response_times, args=(monitoring_results,)),
                threading.Thread(target=self._monitor_resource_usage, args=(monitoring_results,)),
                threading.Thread(target=self._monitor_tenant_isolation, args=(monitoring_results,))
            ]
            
            for monitor in monitors:
                monitor.start()
            
            # Main monitoring loop
            end_time = datetime.now(timezone.utc) + timedelta(minutes=duration_minutes)
            
            while datetime.now(timezone.utc) < end_time and self.monitoring_active:
                self._check_overall_health(monitoring_results)
                
                if monitoring_results['overall_health'] == 'critical':
                    print("🚨 CRITICAL: Deployment issues detected - consider rollback")
                    break
                
                time.sleep(60)  # Check every minute
            
            # Wait for monitoring threads to complete
            for monitor in monitors:
                monitor.join(timeout=30)
            
            monitoring_results['monitoring_end'] = datetime.now(timezone.utc)
            
        except Exception as e:
            print(f"❌ Monitoring failed: {e}")
            monitoring_results['error'] = str(e)
        
        return monitoring_results
    
    def _monitor_error_rates(self, results: Dict[str, Any]):
        """Monitor API and Lambda error rates"""
        
        try:
            while self.monitoring_active:
                # Get error metrics from CloudWatch
                error_metrics = self._get_error_metrics()
                
                # Check thresholds
                for tier, metrics in error_metrics.items():
                    error_rate = metrics.get('error_rate_percent', 0)
                    
                    if error_rate > 5:  # More than 5% errors
                        alert = {
                            'type': 'high_error_rate',
                            'tier': tier,
                            'error_rate': error_rate,
                            'severity': 'critical' if error_rate > 10 else 'warning',
                            'timestamp': datetime.now(timezone.utc)
                        }
                        
                        results['alerts'].append(alert)
                        print(f"🚨 ALERT: High error rate in {tier}: {error_rate}%")
                
                results['metrics']['error_rates'] = error_metrics
                time.sleep(120)  # Check every 2 minutes
                
        except Exception as e:
            print(f"❌ Error rate monitoring failed: {e}")
    
    def _monitor_response_times(self, results: Dict[str, Any]):
        """Monitor API response times"""
        
        try:
            while self.monitoring_active:
                response_times = self._get_response_time_metrics()
                
                for tier, metrics in response_times.items():
                    avg_response_time = metrics.get('average_ms', 0)
                    
                    # Different thresholds for different tiers
                    thresholds = {'basic': 500, 'premium': 200, 'platinum': 100}
                    threshold = thresholds.get(tier, 500)
                    
                    if avg_response_time > threshold:
                        alert = {
                            'type': 'slow_response_time',
                            'tier': tier,
                            'response_time_ms': avg_response_time,
                            'threshold_ms': threshold,
                            'severity': 'warning',
                            'timestamp': datetime.now(timezone.utc)
                        }
                        
                        results['alerts'].append(alert)
                        print(f"⚠️ ALERT: Slow response time in {tier}: {avg_response_time}ms")
                
                results['metrics']['response_times'] = response_times
                time.sleep(180)  # Check every 3 minutes
                
        except Exception as e:
            print(f"❌ Response time monitoring failed: {e}")


class RollbackManager:
    """Manage rollbacks across tenant tiers"""
    
    def __init__(self):
        self.lambda_client = boto3.client('lambda')
        self.dynamodb = boto3.resource('dynamodb')
    
    def execute_rollback(self, rollback_plan: Dict[str, Any]) -> bool:
        """
        🔄 Execute rollback across affected tiers
        
        Like reverting to the old textbooks if new ones have errors:
        - Start with most critical issues first
        - Rollback in reverse order of deployment
        - Verify each rollback step
        """
        
        print("🔄 Starting multi-tier rollback")
        
        rollback_order = ['platinum', 'premium', 'basic']  # Reverse deployment order
        
        for tier in rollback_order:
            if tier in rollback_plan:
                print(f"🔄 Rolling back {tier} tier...")
                
                if not self._rollback_tier(tier, rollback_plan[tier]):
                    print(f"❌ Rollback failed for {tier} tier")
                    return False
                    
                print(f"✅ {tier} tier rollback completed")
        
        print("✅ Multi-tier rollback completed successfully")
        return True
    
    def _rollback_tier(self, tier: str, rollback_info: Dict[str, Any]) -> bool:
        """Rollback specific tier"""
        
        try:
            if tier == 'basic':
                return self._rollback_shared_resources(rollback_info)
            elif tier == 'premium':
                return self._rollback_premium_resources(rollback_info)
            elif tier == 'platinum':
                return self._rollback_dedicated_resources(rollback_info)
            
            return False
            
        except Exception as e:
            print(f"❌ Tier rollback failed for {tier}: {e}")
            return False


## Step 4: Verification and Testing

### 4.1 Post-Deployment Verification

Create `verification/post-deployment-tests.py`:

```python
"""
✅ Post-Deployment Verification

Like doing a final check that all classrooms are working
after the district-wide software update:
- Test core functionality in each tier
- Verify tenant isolation is maintained
- Check performance meets SLA requirements
"""

import requests
import json
import time
from typing import Dict, List, Any

class PostDeploymentVerifier:
    """Verify deployment success across all tenant tiers"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.test_results = {}
    
    def run_full_verification(self) -> Dict[str, Any]:
        """
        🎯 Run comprehensive post-deployment verification
        
        Like having a team of inspectors check every classroom:
        - Functional testing for each tier
        - Performance validation
        - Security verification
        - Integration testing
        """
        
        print("✅ Starting post-deployment verification")
        
        verification_results = {
            'started_at': time.time(),
            'basic_tier': None,
            'premium_tier': None,
            'platinum_tier': None,
            'overall_success': False
        }
        
        try:
            # Test Basic tier (shared resources)
            print("📦 Verifying Basic tier functionality...")
            verification_results['basic_tier'] = self._verify_basic_tier()
            
            # Test Premium tier (semi-dedicated)
            print("💼 Verifying Premium tier functionality...")
            verification_results['premium_tier'] = self._verify_premium_tier()
            
            # Test Platinum tier (dedicated resources)
            print("🏆 Verifying Platinum tier functionality...")
            verification_results['platinum_tier'] = self._verify_platinum_tier()
            
            # Overall success check
            all_tiers_success = all([
                verification_results['basic_tier']['success'],
                verification_results['premium_tier']['success'],
                verification_results['platinum_tier']['success']
            ])
            
            verification_results['overall_success'] = all_tiers_success
            verification_results['completed_at'] = time.time()
            
            if all_tiers_success:
                print("🎉 All verification tests passed!")
            else:
                print("❌ Some verification tests failed")
            
        except Exception as e:
            print(f"❌ Verification failed: {e}")
            verification_results['error'] = str(e)
        
        return verification_results
    
    def _verify_basic_tier(self) -> Dict[str, Any]:
        """Verify Basic tier shared resources work correctly"""
        
        test_results = {
            'success': True,
            'tests_passed': 0,
            'tests_failed': 0,
            'issues': []
        }
        
        basic_tests = [
            ('Create Issue', self._test_create_issue_basic),
            ('List Issues', self._test_list_issues_basic),
            ('Team Assignment', self._test_team_assignment_basic),
            ('Company Isolation', self._test_company_isolation_basic)
        ]
        
        for test_name, test_function in basic_tests:
            try:
                if test_function():
                    test_results['tests_passed'] += 1
                    print(f"  ✅ {test_name}")
                else:
                    test_results['tests_failed'] += 1
                    test_results['success'] = False
                    test_results['issues'].append(f"{test_name} failed")
                    print(f"  ❌ {test_name}")
                    
            except Exception as e:
                test_results['tests_failed'] += 1
                test_results['success'] = False
                test_results['issues'].append(f"{test_name} error: {e}")
                print(f"  ❌ {test_name} - {e}")
        
        return test_results


def main():
    """Main verification orchestration"""
    
    print("🚀 Post-Deployment Verification Suite")
    print("=" * 50)
    
    # Load configuration
    config = {
        'api_base_url': 'https://your-api-gateway.execute-api.us-east-1.amazonaws.com/prod',
        'test_timeout': 30,
        'basic_tier_companies': ['comp_test_basic_001', 'comp_test_basic_002'],
        'premium_tier_companies': ['comp_test_premium_001'],
        'platinum_tier_companies': ['comp_test_platinum_001']
    }
    
    # Run verification
    verifier = PostDeploymentVerifier(config)
    results = verifier.run_full_verification()
    
    # Print summary
    print("\n📊 VERIFICATION SUMMARY")
    print("=" * 30)
    
    if results['overall_success']:
        print("🎉 ALL VERIFICATIONS PASSED")
        print("✅ Deployment successful across all tenant tiers")
        print("✅ All functionality working correctly")
        print("✅ Performance within acceptable limits")
        print("✅ Security isolation maintained")
    else:
        print("❌ VERIFICATION ISSUES DETECTED")
        print("⚠️ Review failed tests and consider rollback")
    
    return results['overall_success']


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)
```

## Step 5: Practical Deployment Example

### 5.1 Execute Multi-Tenant Deployment

**Run the complete deployment pipeline:**

```bash
# 1. Run the multi-tenant deployment
python scripts/deploy-multi-tenant.py

# 2. Monitor the deployment
python monitoring/deployment-monitor.py --duration 30

# 3. Run post-deployment verification
python verification/post-deployment-tests.py

# 4. If issues found, execute rollback
python scripts/rollback-deployment.py --tier basic --version previous
```

### 5.2 Expected Output

**Successful Deployment Flow:**
```
🚀 Multi-Tenant Deployment Pipeline Started
├── 🔧 Development Environment: ✅ PASSED
├── 🧪 Staging Environment: ✅ PASSED  
├── 📦 Basic Tier Production: ✅ PASSED (1,247 companies updated)
├── 💼 Premium Tier Production: ✅ PASSED (89 companies updated)
└── 🏆 Platinum Tier Production: ✅ PASSED (12 companies updated)

📊 Deployment Monitoring (30 minutes)
├── Error Rate: 0.02% (Well within 0.1% threshold)
├── Response Time: Avg 145ms (Below 200ms target)
├── Resource Usage: Normal levels
└── Tenant Isolation: ✅ Verified

✅ Post-Deployment Verification
├── Basic Tier: 15/15 tests passed
├── Premium Tier: 18/18 tests passed  
├── Platinum Tier: 12/12 individual customer tests passed
└── Overall: 🎉 ALL SYSTEMS OPERATIONAL

🎉 Deployment v2024.01.15.1430 SUCCESSFUL!
```

## Key Takeaways and Best Practices

### 🏆 **What We Accomplished**

**Multi-Tier Deployment Strategy:**
- ✅ **Shared Resource Updates** for Basic tier efficiency
- ✅ **Semi-Dedicated Updates** for Premium tier balance  
- ✅ **Individual Updates** for Platinum tier isolation
- ✅ **Automated Monitoring** during deployments
- ✅ **Rollback Capabilities** for each tier independently

### 📋 **Deployment Checklist**

**Before Each Deployment:**
- [ ] All tests pass in development environment
- [ ] Staging environment mirrors production setup
- [ ] Database migration scripts tested and reversible
- [ ] Rollback plan prepared for each tier
- [ ] Customer notifications sent (for Platinum tier)
- [ ] Monitoring dashboards ready
- [ ] Support team notified and on standby

**During Deployment:**
- [ ] Monitor error rates continuously
- [ ] Check response times meet SLA requirements
- [ ] Verify tenant isolation maintained
- [ ] Watch for any unusual patterns or spikes
- [ ] Have rollback ready to execute immediately

**After Deployment:**
- [ ] Run comprehensive verification tests
- [ ] Check all customer tiers are functioning
- [ ] Monitor for 24 hours post-deployment
- [ ] Document any issues and resolutions
- [ ] Update deployment procedures based on learnings

### 🚨 **Critical Success Factors**

1. **Tier-Appropriate Strategy**: Different approaches for different customer value
2. **Comprehensive Monitoring**: Real-time visibility into deployment health
3. **Quick Rollback**: Ability to revert changes rapidly if issues arise
4. **Customer Communication**: Especially important for Platinum customers
5. **Testing at Scale**: Staging must represent production complexity

## What's Next? 🚀

You now have a robust multi-tenant deployment strategy that can handle:
- **1,000+ Basic tier customers** with shared resource updates
- **50+ Premium tier customers** with coordinated deployments
- **10+ Platinum tier customers** with individual deployment schedules

This approach scales with your business and ensures that your issue tracking SaaS can grow from startup to enterprise scale while maintaining reliability and customer satisfaction! 🌟
