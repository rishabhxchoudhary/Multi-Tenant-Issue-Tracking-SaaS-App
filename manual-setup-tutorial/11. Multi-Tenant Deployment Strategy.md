# 🚀 Part 11: Multi-Tenant Deployment Strategy - Console Setup

## What We'll Accomplish in This Part

By the end of this tutorial, you will:

- ✅ Deploy a production-ready multi-tenant SaaS platform using AWS Console exclusively
- ✅ Set up automated CI/CD pipelines through console interfaces
- ✅ Configure environment-specific deployments (dev, staging, production)
- ✅ Implement blue-green deployments for zero-downtime updates
- ✅ Set up auto-scaling and performance optimization for thousands of tenants
- ✅ Configure comprehensive monitoring and alerting through CloudWatch console
- ✅ Implement automated backup and disaster recovery strategies
- ✅ Set up production security hardening and compliance monitoring
- ✅ Configure cost optimization and resource management
- ✅ Scale deployment from 10 to 10,000+ companies with 80% operational overhead reduction
- ✅ Achieve enterprise-grade deployment with 3-5x better performance than traditional approaches

**⏰ Estimated Time: 240-280 minutes**

## What is Multi-Tenant Deployment Strategy? (Simple Explanation)

### Traditional Multi-System Deployment (The Complex Way)

Think of traditional SaaS deployment like **managing multiple separate restaurants**:

🍽️ **The Old Way - Separate Restaurant Chains**:
- Restaurant 1: Deploy user management system separately
- Restaurant 2: Deploy database systems individually
- Restaurant 3: Deploy API services with different configurations
- Restaurant 4: Deploy frontend applications per environment
- Restaurant 5: Deploy monitoring systems independently

**Problems with this approach**:
- 💰 **Expensive**: Manage deployment pipelines for dozens of separate systems
- 🐌 **Slow**: Deploy and coordinate updates across disconnected services
- 🔧 **Complex**: Different deployment strategies for each component
- 📊 **Error-Prone**: Inconsistent deployments across environments
- 🚫 **Difficult Scaling**: Each system needs individual scaling configuration

### Single-Table Multi-Tenant Deployment (The Smart Way)

Think of optimized deployment like **managing one intelligent restaurant franchise system**:

🏗️ **The New Way - Unified Franchise Management**:
- One intelligent deployment system manages everything
- Environment 1: Dev environment with all tenant data together but isolated
- Environment 2: Staging environment mirrors production exactly
- Environment 3: Production environment with thousands of tenants efficiently managed
- Smart deployment system handles all environments consistently
- Unified monitoring and management across all environments

**Benefits of this approach**:
- 💰 **80% Deployment Cost Reduction**: One pipeline instead of many
- ⚡ **3-5x Faster Deployments**: Single deployment updates entire multi-tenant system
- 🔒 **Consistent Tenant Isolation**: Deployment maintains perfect data separation
- 📊 **Simplified Operations**: One system to deploy, monitor, and maintain
- 🎯 **Zero-Downtime Updates**: Blue-green deployments work seamlessly with single-table design

## Understanding Our Deployment Architecture

### Console-First Deployment Benefits

🖥️ **Visual Deployment Management**:
- Monitor deployments through CodePipeline console interfaces
- Track multi-tenant performance through CloudWatch dashboards
- Manage environment-specific configurations through Parameter Store console
- Handle disaster recovery through automated console workflows

### 11.1 Our Multi-Tenant Deployment Strategy

In our unified deployment approach:

**Environment Structure**:
```
Production Environment:
├── Single DynamoDB table: IssueTracker-MainTable-Prod
├── All tenant data isolated but co-located
├── Unified Lambda functions handle all companies
└── Single API Gateway serves all tenants

Staging Environment:
├── Single DynamoDB table: IssueTracker-MainTable-Staging
├── Mirror of production with test tenant data
├── Same Lambda functions with staging configuration
└── Complete production simulation

Development Environment:
├── Single DynamoDB table: IssueTracker-MainTable-Dev
├── Developer tenant data for testing
├── Rapid deployment for feature development
└── Simplified configuration for development speed
```

**Deployment Pipeline Benefits**:
- **Single Pipeline**: Deploy entire multi-tenant system together
- **Atomic Updates**: All tenants get updates simultaneously
- **Consistent State**: No version mismatches between tenant data
- **Simplified Rollback**: Single rollback affects all tenants equally

### 11.2 Zero-Downtime Multi-Tenant Updates

**Blue-Green Deployment for Thousands of Tenants**:
1. **Blue Environment**: Current production serving all companies
2. **Green Environment**: New version deployed and tested
3. **Traffic Switch**: Route all tenant traffic to green environment
4. **Validation**: Verify all companies working correctly
5. **Cleanup**: Decommission blue environment

**⚡ Performance**: Switch thousands of tenants instantly instead of migrating each separately

## Step 1: Set Up Multi-Environment Infrastructure

### 1.1 Access Systems Manager Parameter Store

1. 🔗 **Sign in to AWS Console**: https://console.aws.amazon.com
2. 🔍 **Search for "Systems Manager"** in the top search bar
3. 📱 **Click "Systems Manager"** from the services dropdown
4. 🌍 **Verify Region**: Ensure you're in your deployment region

✅ **Expected Result**: You should see the Systems Manager console

### 1.2 Create Environment-Specific Parameters

1. **Click "Parameter Store"** in the left navigation
2. **Click "Create parameter"**

**Create Development Environment Parameters:**

**Parameter 1: Database Configuration**
- **Name**: `/issuetracker/dev/database/table-name`
- **Type**: `String`
- **Value**: `IssueTracker-MainTable-Dev`
- **Description**: `DynamoDB table for development environment`
- **Click "Create parameter"**

**Parameter 2: API Configuration**
- **Name**: `/issuetracker/dev/api/base-url`
- **Type**: `String`
- **Value**: `https://dev-api.your-domain.com`
- **Description**: `Base URL for development API`
- **Click "Create parameter"**

**Parameter 3: Cognito Configuration**
- **Name**: `/issuetracker/dev/auth/user-pool-id`
- **Type**: `String`
- **Value**: `[your-dev-user-pool-id]`
- **Description**: `Cognito User Pool for development`
- **Click "Create parameter"**

**Create Staging Environment Parameters:**

**Repeat the process for staging environment:**
- `/issuetracker/staging/database/table-name` → `IssueTracker-MainTable-Staging`
- `/issuetracker/staging/api/base-url` → `https://staging-api.your-domain.com`
- `/issuetracker/staging/auth/user-pool-id` → `[your-staging-user-pool-id]`

**Create Production Environment Parameters:**

**Repeat for production environment:**
- `/issuetracker/prod/database/table-name` → `IssueTracker-MainTable-Prod`
- `/issuetracker/prod/api/base-url` → `https://api.your-domain.com`
- `/issuetracker/prod/auth/user-pool-id` → `[your-prod-user-pool-id]`

✅ **Expected Result**: Environment-specific parameters configured for all environments

### 1.3 Create Production DynamoDB Table

1. **Go to DynamoDB Console**
2. **Click "Create table"**
3. **Configure Production Table**:
   - **Table name**: `IssueTracker-MainTable-Prod`
   - **Partition key**: `PK` (String)
   - **Sort key**: `SK` (String)
   - **Settings**: `Default settings`
   - **Billing mode**: `On-demand` (for variable production workloads)
4. **Click "Create table"**

**Configure Global Secondary Index (GSI1):**
1. **After table creation**, click on the table
2. **Go to "Indexes" tab** → **"Create index"**
3. **Index Configuration**:
   - **Index name**: `GSI1`
   - **Partition key**: `GSI1PK` (String)
   - **Sort key**: `GSI1SK` (String)
   - **Projection**: `All attributes`
4. **Click "Create index"**

**Configure Additional GSI for Cross-Tenant Queries:**
1. **Create another index**: `CrossTenantIndex`
2. **Configuration**:
   - **Partition key**: `entity_type` (String)
   - **Sort key**: `created_date` (String)
   - **Projection**: `All attributes`
3. **Click "Create index"**

### 1.4 Create Staging Environment

**Create Staging DynamoDB Table:**
1. **Repeat DynamoDB table creation** with name `IssueTracker-MainTable-Staging`
2. **Same configuration** as production but smaller scale
3. **Same GSIs** for complete production simulation

**Create Staging Cognito User Pool:**
1. **Go to Cognito Console**
2. **Create User Pool**: `IssueTracker-UserPool-Staging`
3. **Same configuration** as production
4. **Create test users** for staging validation

✅ **Expected Result**: Complete staging environment mirrors production

**⏰ Time Check**: Environment setup should take ~45 minutes

## Step 2: Set Up CI/CD Pipeline with CodePipeline

### 2.1 Access CodePipeline Console

1. **Search for "CodePipeline"** in AWS Console
2. **Click "CodePipeline"**
3. **Click "Create pipeline"**

### 2.2 Create Multi-Tenant Deployment Pipeline

**Pipeline Configuration:**

1. **Pipeline Name**: `IssueTracker-MultiTenant-Pipeline`
2. **Service Role**:
   - Select "New service role"
   - **Role name**: `IssueTracker-CodePipeline-Role`
3. **Advanced Settings**:
   - **Artifact store**: Default location
   - **Encryption**: Default AWS Managed Key
4. **Click "Next"**

### 2.3 Configure Source Stage

**Source Provider Configuration:**

1. **Source provider**: `Amazon S3` (or GitHub if using repository)
2. **Bucket**: Create new bucket `issuetracker-deployment-source`
3. **S3 object key**: `source-code.zip`
4. **Output artifacts**: `SourceOutput`
5. **Click "Next"**

### 2.4 Add Build Stage

**Build Provider Configuration:**

1. **Build provider**: `AWS CodeBuild`
2. **Region**: Your deployment region
3. **Project name**: Click "Create project"

**CodeBuild Project Configuration:**
1. **Project name**: `IssueTracker-MultiTenant-Build`
2. **Environment**:
   - **Environment image**: `Managed image`
   - **Operating system**: `Amazon Linux 2`
   - **Runtime**: `Standard`
   - **Image**: `aws/codebuild/amazonlinux2-x86_64-standard:3.0`
   - **Service role**: Create new role `IssueTracker-CodeBuild-Role`

3. **Buildspec**: Select "Insert build commands"
4. **Build Commands**:

```yaml
version: 0.2
phases:
  install:
    runtime-versions:
      python: 3.9
      nodejs: 16
  pre_build:
    commands:
      - echo Installing dependencies
      - pip install boto3 pytest
      - npm install -g aws-cli
  build:
    commands:
      - echo Build started on `date`
      - echo Building multi-tenant Lambda functions
      - # Package Lambda functions
      - zip -r issue-manager.zip lambda/issue-manager/
      - zip -r team-manager.zip lambda/team-manager/
      - zip -r company-manager.zip lambda/company-manager/
      - echo Build completed on `date`
  post_build:
    commands:
      - echo Running multi-tenant tests
      - python -m pytest tests/ -v
      - echo Multi-tenant build and test completed
artifacts:
  files:
    - '**/*'
  name: MultiTenantBuildArtifact
```

5. **Click "Continue to CodePipeline"**
6. **Click "Next"**

### 2.5 Add Deploy Stage

**Deploy Provider Configuration:**

1. **Deploy provider**: `AWS Lambda`
2. **Region**: Your deployment region
3. **Function name**: `IssueTracker-IssueManager`
4. **Click "Next"**
5. **Review and create pipeline**

✅ **Expected Result**: Complete CI/CD pipeline created for multi-tenant deployment

### 2.6 Configure Environment-Specific Deployments

**Add Staging Deployment Stage:**

1. **Edit Pipeline** → **Add stage**
2. **Stage name**: `Deploy-Staging`
3. **Add Action**:
   - **Action name**: `Deploy-to-Staging`
   - **Action provider**: `AWS Lambda`
   - **Function name**: `IssueTracker-IssueManager-Staging`
   - **Environment variables**: Reference staging parameters

**Add Production Deployment Stage:**

1. **Add another stage**: `Deploy-Production`
2. **Add manual approval action**:
   - **Action name**: `Manual-Approval-for-Production`
   - **Action provider**: `Manual approval`
   - **Review URL**: Link to staging environment for testing
3. **Add deployment action**:
   - **Action name**: `Deploy-to-Production`
   - **Action provider**: `AWS Lambda`
   - **Function name**: Production Lambda functions

✅ **Expected Result**: Multi-stage pipeline with manual production approval

**⏰ Time Check**: CI/CD pipeline setup should take ~60 minutes

## Step 3: Configure Auto-Scaling and Performance Optimization

### 3.1 Access Lambda Console for Scaling Configuration

1. **Go to Lambda Console**
2. **Click on** `IssueTracker-IssueManager`
3. **Click "Configuration" tab**

### 3.2 Configure Lambda Scaling Settings

**Concurrent Execution Limits:**

1. **Click "Concurrency"** in left sidebar
2. **Click "Edit"**
3. **Reserved concurrency**: `100` (for production)
4. **Provisioned concurrency**:
   - **Version**: `$LATEST`
   - **Provisioned concurrency**: `10` (warm instances)
5. **Click "Save"**

**Memory and Timeout Optimization:**

1. **Click "General configuration"** → **"Edit"**
2. **Memory**: `1024 MB` (optimized for multi-tenant operations)
3. **Timeout**: `2 min 0 sec`
4. **Description**: `Production multi-tenant issue management function`
5. **Click "Save"**

### 3.3 Configure DynamoDB Auto-Scaling

1. **Go to DynamoDB Console**
2. **Click on** `IssueTracker-MainTable-Prod`
3. **Go to "Additional settings" tab**
4. **Click "Manage capacity"**

**Configure Auto-Scaling:**

1. **Read capacity**:
   - **Capacity mode**: `On-demand` (automatically scales)
   - **Maximum read request units**: `40000` per second
2. **Write capacity**:
   - **Capacity mode**: `On-demand`
   - **Maximum write request units**: `40000` per second
3. **Click "Save changes"**

**Configure GSI Auto-Scaling:**

1. **Go to "Indexes" tab**
2. **For each GSI**, click "Manage capacity"
3. **Set same auto-scaling settings** as main table
4. **Click "Save changes"**

### 3.4 Set Up API Gateway Throttling

1. **Go to API Gateway Console**
2. **Click on** `IssueTracker-API`
3. **Click "Usage Plans"** in left navigation
4. **Click "Create"**

**Create Production Usage Plan:**

1. **Name**: `Production-Multi-Tenant-Plan`
2. **Description**: `Production usage plan for all tenants`
3. **Throttling**:
   - **Rate**: `10000` requests per second
   - **Burst**: `5000` concurrent requests
4. **Quota**:
   - **Requests per month**: `10000000` (10M requests)
5. **Click "Create"**

**Associate API Stages:**

1. **Click "Add API Stage"**
2. **API**: `IssueTracker-API`
3. **Stage**: `prod`
4. **Click "Add API Stage"**

✅ **Expected Result**: Auto-scaling configured for multi-tenant production load

### 3.5 Configure CloudFront for Global Performance

1. **Go to CloudFront Console**
2. **Click "Create Distribution"**

**Distribution Configuration:**

1. **Origin Domain**: Your API Gateway domain
2. **Origin Path**: `/prod`
3. **Origin Protocol Policy**: `HTTPS Only`
4. **Cache Policy**: `CachingDisabled` (for API responses)
5. **Origin Request Policy**: `CORS-S3Origin`
6. **Allowed HTTP Methods**: `GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE`
7. **Price Class**: `Use All Edge Locations` (global performance)
8. **Alternate Domain Names**: `api.your-domain.com`
9. **SSL Certificate**: Request AWS Certificate Manager certificate
10. **Click "Create Distribution"**

✅ **Expected Result**: Global CDN configured for multi-tenant API performance

**⏰ Time Check**: Performance optimization should take ~50 minutes

## Step 4: Set Up Comprehensive Monitoring and Alerting

### 4.1 Create Production Monitoring Dashboard

1. **Go to CloudWatch Console**
2. **Click "Dashboards"** → **"Create dashboard"**
3. **Dashboard name**: `IssueTracker-Production-MultiTenant`

### 4.2 Add Multi-Tenant Performance Widgets

**Widget 1: Multi-Tenant Lambda Performance**

1. **Add widget** → **"Line"**
2. **Configure metrics**:
   - **Source**: `AWS/Lambda`
   - **Metrics**: `Duration`, `Invocations`, `Errors`, `Throttles`
   - **Functions**: All IssueTracker functions
3. **Widget title**: `Multi-Tenant Lambda Performance`
4. **Time range**: `Last 24 hours`
5. **Click "Create widget"**

**Widget 2: Single-Table Database Performance**

1. **Add widget** → **"Line"**
2. **Configure metrics**:
   - **Source**: `AWS/DynamoDB`
   - **Table**: `IssueTracker-MainTable-Prod`
   - **Metrics**: `ConsumedReadCapacityUnits`, `ConsumedWriteCapacityUnits`, `SuccessfulRequestLatency`, `ThrottledRequests`
3. **Widget title**: `Single-Table Multi-Tenant Database Performance`
4. **Click "Create widget"**

**Widget 3: API Gateway Multi-Tenant Traffic**

1. **Add widget** → **"Line"**
2. **Configure metrics**:
   - **Source**: `AWS/ApiGateway`
   - **API**: `IssueTracker-API`
   - **Metrics**: `Count`, `Latency`, `4XXError`, `5XXError`
3. **Widget title**: `Multi-Tenant API Performance`
4. **Click "Create widget"**

**Widget 4: Cross-Tenant Analytics**

1. **Add widget** → **"Number"**
2. **Configure custom metrics**:
   - **Namespace**: `IssueTracker/MultiTenant`
   - **Metrics**: `ActiveCompanies`, `TotalUsers`, `IssuesPerSecond`
3. **Widget title**: `Cross-Tenant Platform Metrics`
4. **Click "Create widget"**

### 4.3 Set Up Critical Production Alarms

**Alarm 1: Multi-Tenant Performance Degradation**

1. **Go to "Alarms"** → **"Create alarm"**
2. **Metric**: `AWS/Lambda` → `Duration`
3. **Function**: All IssueTracker functions
4. **Statistic**: `Average`
5. **Period**: `5 minutes`
6. **Conditions**: `Greater than 5000` milliseconds
7. **Datapoints**: `2 out of 2`
8. **Alarm name**: `Multi-Tenant-Performance-Degradation`
9. **Alarm description**: `Multi-tenant Lambda functions performing slowly`
10. **SNS Topic**: Create new topic `IssueTracker-Production-Alerts`
11. **Click "Create alarm"**

**Alarm 2: Database Throttling**

1. **Create alarm** for DynamoDB throttling
2. **Metric**: `AWS/DynamoDB` → `ThrottledRequests`
3. **Table**: `IssueTracker-MainTable-Prod`
4. **Threshold**: `Greater than 0`
5. **Alarm name**: `Multi-Tenant-Database-Throttling`

**Alarm 3: Cross-Tenant Error Rate**

1. **Create alarm** for API Gateway errors
2. **Metric**: `AWS/ApiGateway` → `5XXError`
3. **Threshold**: `Greater than 10` errors in 5 minutes
4. **Alarm name**: `Multi-Tenant-API-Errors`

**Alarm 4: Tenant Isolation Failure**

1. **Create alarm** for custom security metrics
2. **Metric**: `IssueTracker/Security` → `CrossTenantAccessAttempts`
3. **Threshold**: `Greater than 0`
4. **Alarm name**: `Tenant-Isolation-Breach-Attempt`

### 4.4 Configure Log Aggregation

1. **Go to CloudWatch Logs**
2. **Create Log Group**: `/aws/lambda/issuetracker/production`
3. **Retention**: `30 days`
4. **Set up Log Insights queries**:

**Query 1: Multi-Tenant Performance Analysis**
```
fields @timestamp, @message, @duration, company_id
| filter @type = "REPORT"
| stats avg(@duration), max(@duration), min(@duration) by company_id
| sort avg desc
```

**Query 2: Cross-Tenant Security Monitoring**
```
fields @timestamp, @message, company_id, user_email, attempted_company
| filter @message like /cross.*tenant.*access/
| stats count() by company_id, attempted_company
```

✅ **Expected Result**: Comprehensive production monitoring for multi-tenant operations

**⏰ Time Check**: Monitoring setup should take ~40 minutes

## Step 5: Implement Backup and Disaster Recovery

### 5.1 Configure DynamoDB Point-in-Time Recovery

1. **Go to DynamoDB Console**
2. **Click on** `IssueTracker-MainTable-Prod`
3. **Go to "Backups" tab**
4. **Point-in-time recovery**:
   - **Click "Edit"**
   - **Enable point-in-time recovery**
   - **Click "Save changes"**

**Create On-Demand Backup:**

1. **Click "Create backup"**
2. **Backup name**: `IssueTracker-MultiTenant-Initial-Backup`
3. **Description**: `Initial production backup before first deployment`
4. **Click "Create backup"**

### 5.2 Set Up Cross-Region Disaster Recovery

**Create Disaster Recovery DynamoDB Table:**

1. **Switch to disaster recovery region** (e.g., us-west-2)
2. **Create DynamoDB table**: `IssueTracker-MainTable-DR`
3. **Same configuration** as production table
4. **Enable DynamoDB Global Tables**:
   - **Go to production table** → **Global Tables tab**
   - **Click "Create replica"**
   - **Select DR region** and table
   - **Click "Create replica"**

### 5.3 Configure Lambda Function Backup

**Export Lambda Function Code:**

1. **Go to Lambda Console**
2. **For each function**, click **"Actions"** → **"Export function"**
3. **Download as**: `.zip file`
4. **Store in S3 backup bucket**: `issuetracker-lambda-backups`

**Set up Automated Lambda Backup:**

1. **Create S3 bucket**: `issuetracker-automated-backups`
2. **Enable versioning**
3. **Create Lambda function** for automated backups:
   - **Function name**: `IssueTracker-Backup-Automation`
   - **Trigger**: CloudWatch Events (daily)
   - **Purpose**: Backup all Lambda functions automatically

### 5.4 Create Disaster Recovery Runbook

**Create Systems Manager Document:**

1. **Go to Systems Manager Console**
2. **Click "Documents"** → **"Create document"**
3. **Document name**: `IssueTracker-Disaster-Recovery-Runbook`
4. **Document type**: `Automation`
5. **Content**:

```yaml
schemaVersion: '0.3'
description: 'Disaster Recovery Runbook for Multi-Tenant IssueTracker'
assumeRole: 'arn:aws:iam::{{global:ACCOUNT_ID}}:role/IssueTracker-DR-Role'
parameters:
  DisasterRecoveryRegion:
    type: String
    description: 'Region to failover to'
    default: 'us-west-2'
mainSteps:
  - name: 'VerifyDREnvironment'
    action: 'aws:executeAwsApi'
    inputs:
      Service: 'dynamodb'
      Api: 'DescribeTable'
      TableName: 'IssueTracker-MainTable-DR'
  - name: 'UpdateDNSRecords'
    action: 'aws:executeAwsApi'
    inputs:
      Service: 'route53'
      Api: 'ChangeResourceRecordSets'
      # Point API domain to DR region
  - name: 'NotifyStakeholders'
    action: 'aws:executeAwsApi'
    inputs:
      Service: 'sns'
      Api: 'Publish'
      TopicArn: 'arn:aws:sns:{{global:REGION}}:{{global:ACCOUNT_ID}}:disaster-recovery-notifications'
      Message: 'Disaster recovery initiated for IssueTracker multi-tenant platform'
```

✅ **Expected Result**: Complete disaster recovery strategy for multi-tenant platform

### 5.5 Test Disaster Recovery Procedures

**Disaster Recovery Test Plan:**

1. **Schedule monthly DR tests**
2. **Test scenarios**:
   - Complete region failure
   - Database corruption
   - Application failure
   - Security incident response
3. **Document recovery times**
4. **Update procedures based on test results**

✅ **Expected Result**: Tested and verified disaster recovery capabilities

**⏰ Time Check**: Backup and DR setup should take ~45 minutes

## Step 6: Production Security Hardening

### 6.1 Configure AWS WAF for API Protection

1. **Go to AWS WAF Console**
2. **Click "Create web ACL"**

**Web ACL Configuration:**

1. **Name**: `IssueTracker-Multi-Tenant-Protection`
2. **Resource type**: `CloudFront distributions`
3. **Associated AWS resources**: Select your CloudFront distribution
4. **Add rules**:

**Rule 1: Rate Limiting per Company**
- **Rule name**: `Multi-Tenant-Rate-Limiting`
- **Type**: `Rate-based rule`
- **Rate limit**: `2000` requests per 5-minute period
- **Scope**: `All requests`
- **Action**: `Block`

**Rule 2: SQL Injection Protection**
- **Rule name**: `SQL-Injection-Protection`
- **Type**: `Managed rule group`
- **Rule group**: `AWS-AWSManagedRulesKnownBadInputsRuleSet`
- **Action**: `Block`

**Rule 3: Cross-Site Scripting Protection**
- **Rule name**: `XSS-Protection`
- **Type**: `Managed rule group`
- **Rule group**: `AWS-AWSManagedRulesCommonRuleSet`
- **Action**: `Block`

5. **Click "Create web ACL"**

### 6.2 Configure VPC for Enhanced Security

**Create Production VPC:**

1. **Go to VPC Console**
2. **Click "Create VPC"**
3. **VPC Configuration**:
   - **Name**: `IssueTracker-Production-VPC`
   - **IPv4 CIDR**: `10.0.0.0/16`
   - **Tenancy**: `Default`
   - **Enable DNS hostnames**: ✅
   - **Enable DNS resolution**: ✅
4. **Create subnets**:
   - **Private subnet 1**: `10.0.1.0/24` (Lambda functions)
   - **Private subnet 2**: `10.0.2.0/24` (Database access)
   - **Public subnet**: `10.0.3.0/24` (NAT Gateway)

**Configure Lambda VPC Settings:**

1. **Go to Lambda Console**
2. **For each production function**:
   - **Configuration** → **VPC**
   - **VPC**: `IssueTracker-Production-VPC`
   - **Subnets**: Select private subnets
   - **Security groups**: Create restrictive security group
   - **Click "Save"**

### 6.3 Set Up Secrets Management

1. **Go to Secrets Manager Console**
2. **Click "Store a new secret"**

**Create Production Secrets:**

**Secret 1: Database Encryption Keys**
- **Secret type**: `Other type of secret`
- **Key/value pairs**:
  - `database-encryption-key`: `[generated-key]`
  - `jwt-signing-key`: `[generated-key]`
- **Secret name**: `issuetracker/prod/encryption-keys`
- **Description**: `Encryption keys for production multi-tenant environment`

**Secret 2: Third-party API Keys**
- **Secret name**: `issuetracker/prod/api-keys`
- **Key/value pairs**:
  - `sendgrid-api-key`: `[your-key]`
  - `slack-webhook-url`: `[your-webhook]`

**Update Lambda Functions to Use Secrets:**

1. **Add IAM permission** to Lambda execution role:
   - **Policy**: `SecretsManagerReadWrite`
2. **Update function code** to retrieve secrets at runtime

### 6.4 Enable AWS Config for Compliance

1. **Go to AWS Config Console**
2. **Click "Get started"**
3. **Settings**:
   - **Resource types**: `Record all resources`
   - **S3 bucket**: Create new bucket for Config
   - **SNS topic**: `IssueTracker-Config-Notifications`
4. **Add rules**:

**Rule 1: DynamoDB Encryption**
- **Rule name**: `dynamodb-table-encryption-enabled`
- **Source**: `AWS managed rules`
- **Trigger**: Configuration changes

**Rule 2: Lambda Function Security**
- **Rule name**: `lambda-function-public-read-prohibited`
- **Source**: `AWS managed rules`

**Rule 3: API Gateway SSL**
- **Rule name**: `api-gw-ssl-enabled`
- **Source**: `AWS managed rules`

5. **Click "Confirm"**

✅ **Expected Result**: Production environment secured with enterprise-grade security controls

**⏰ Time Check**: Security hardening should take ~55 minutes

## Step 7: Deploy and Test Production Environment

### 7.1 Execute Initial Production Deployment

1. **Go to CodePipeline Console**
2. **Click on** `IssueTracker-MultiTenant-Pipeline`
3
