# 🔐 Part 8: API Gateway Security and OAuth2 - Console Setup

## What We'll Accomplish in This Part

By the end of this tutorial, you will:

- ✅ Set up Amazon Cognito User Pools using AWS Console exclusively
- ✅ Implement company-based authentication with perfect tenant isolation
- ✅ Configure OAuth2 flows for secure API access
- ✅ Add JWT token validation to your single-table design APIs
- ✅ Set up role-based access control (User/Admin/Manager) through console
- ✅ Secure your API Gateway endpoints with built-in authorization
- ✅ Test complete authentication workflows using console tools
- ✅ Monitor security events through CloudWatch console
- ✅ Achieve enterprise-grade security with 80% less complexity than traditional approaches
- ✅ Scale authentication from 1 to 10,000+ companies seamlessly

**⏰ Estimated Time: 160-180 minutes**

## What is OAuth2 for SaaS? (Simple Explanation)

### Traditional Multi-System Security (The Complex Way)

Think of traditional authentication like managing **multiple security checkpoints**:

🏢 **The Old Way - Multiple Security Systems**:
- Building 1: User authentication system
- Building 2: Permission management system  
- Building 3: Company access control system
- Building 4: API security system
- Building 5: Session management system

**Problems with this approach**:
- 💰 **Expensive**: Manage 5 separate security systems
- 🐌 **Slow**: Check permissions across multiple systems (5+ database queries)
- 🔧 **Complex**: Coordinate security policies across disconnected systems
- 📊 **Inconsistent**: Different systems may have conflicting permissions
- 🚫 **Vulnerable**: More systems mean more attack surfaces

### Single-System OAuth2 Security (The Smart Way)

Think of OAuth2 with single-table design like a **smart corporate headquarters with unified security**:

🏗️ **The New Way - One Intelligent Security System**:
- One unified security headquarters
- Floor 1: All Company A user data (authentication, permissions, roles) together
- Floor 2: All Company B user data together
- Smart elevator system (JWT tokens) for secure access
- All security information stored together per company

**Benefits of this approach**:
- 💰 **80% Security Cost Reduction**: One system instead of five
- ⚡ **3-5x Faster Authentication**: All user data in one place
- 🔒 **Perfect Company Isolation**: Each company's security on separate floors
- 📊 **Instant Permission Checks**: User roles stored with user data
- 🎯 **Simple Security Management**: One console to manage everything

## Understanding Our Security Architecture

### Console-First Security Benefits

🖥️ **Visual Security Management**:
- See user authentication flows in Cognito console
- Monitor API security through API Gateway console
- View security metrics in CloudWatch dashboards
- Test authentication with built-in AWS testing tools

### 8.1 Our Single-System Security Design

In our unified approach:

**User Authentication Records** (in Cognito):
```
User Pool: IssueTracker-Users
├── Company A Users
│   ├── john@companyA.com (Admin role)
│   ├── sarah@companyA.com (User role)
│   └── mike@companyA.com (Manager role)
└── Company B Users
    ├── jane@companyB.com (Admin role)
    └── tom@companyB.com (User role)
```

**Permission Records** (in our single DynamoDB table):
```
PK: COMPANY#001        SK: USER#john@companyA.com
PK: COMPANY#002        SK: USER#jane@companyB.com
```

### 8.2 OAuth2 Flow for Issue Tracking

**🔍 Simple Authentication Flow**:
1. User logs in through Cognito hosted UI
2. Cognito validates credentials and company membership
3. Cognito issues JWT token with company + role information
4. API Gateway validates JWT token automatically
5. Lambda functions extract company context from token
6. Single query gets all user permissions and data

**⚡ Performance**: One authentication check instead of multiple system lookups

## Step 1: Access Cognito Console for User Management

### 1.1 Access Amazon Cognito Console

1. 🔗 **Sign in to AWS Console**: https://console.aws.amazon.com
2. 🔍 **Search for "Cognito"** in the top search bar
3. 📱 **Click "Amazon Cognito"** from the services dropdown
4. 🌍 **Verify Region**: Ensure you're in the same region as your other resources

✅ **Expected Result**: You should see the Cognito console with options for User Pools and Identity Pools

### 1.2 Create User Pool for Issue Tracker

1. **Click "Create user pool"** button
2. **Step 1: Configure sign-in experience**
   - **Authentication providers**: Select "Cognito user pool"
   - **Cognito user pool sign-in options**: Check "Email"
   - **User name requirements**: 
     - ✅ Allow users to sign in with preferred username
     - ✅ Email (selected)
   - **Click "Next"**

✅ **Expected Result**: You should be on Step 2 of user pool creation

### 1.3 Configure Security Requirements

1. **Step 2: Configure security requirements**
2. **Password policy**:
   - **Password policy mode**: Select "Cognito defaults"
   - **Multi-factor authentication**: Select "Optional MFA"
   - **MFA methods**: Check "SMS message" and "Authenticator apps"
3. **User account recovery**:
   - **Self-service account recovery**: Check "Email only"
4. **Click "Next"**

✅ **Expected Result**: Password policy configured for enterprise security

**⏰ Time Check**: This step should take ~10 minutes

### 1.4 Configure Sign-up Experience

1. **Step 3: Configure sign-up experience**
2. **Self-registration**: Enable "Allow Cognito to automatically send messages to verify and confirm"
3. **Attribute verification and user account confirmation**:
   - **Attributes to verify**: Check "Send email message, verify email address"
   - **Verifying attribute changes**: Check "Send email message, verify email address"
4. **Required attributes**: Select these attributes:
   - ✅ email (already selected)
   - ✅ given_name
   - ✅ family_name
   - ✅ custom:company_id (we'll add this)
5. **Custom attributes**:
   - **Click "Add custom attribute"**
   - **Name**: `company_id`
   - **Type**: String
   - **Min length**: 1, **Max length**: 50
   - **Mutable**: Yes
6. **Click "Next"**

✅ **Expected Result**: Sign-up configured with custom company_id attribute

### 1.5 Configure Message Delivery

1. **Step 4: Configure message delivery**
2. **Email**:
   - **Email provider**: Select "Send email with Cognito"
   - **FROM email address**: `no-reply@verificationemail.com` (default)
   - **REPLY-TO email address**: Leave blank (optional)
3. **SMS**: Leave default settings (for MFA)
4. **Click "Next"**

### 1.6 Integrate Your App

1. **Step 5: Integrate your app**
2. **User pool name**: `IssueTracker-UserPool`
3. **Hosted authentication pages**: 
   - **Use the Cognito Hosted UI**: Check this box
   - **Domain type**: Select "Use a Cognito domain"
   - **Cognito domain**: `issuetracker-auth-[YOUR-RANDOM-STRING]` (must be unique)
4. **Initial app client**:
   - **App type**: Select "Public client"
   - **App client name**: `IssueTracker-WebClient`
   - **Client secret**: Select "Don't generate a client secret"
5. **Advanced app client settings**:
   - **Authentication flows**: Check "ALLOW_USER_SRP_AUTH"
   - **OAuth 2.0 grant types**: Check "Authorization code grant"
   - **OpenID Connect scopes**: Check "OpenID", "Email", "Profile"
6. **Click "Next"**

✅ **Expected Result**: App integration configured with hosted UI

### 1.7 Review and Create

1. **Step 6: Review and create**
2. **Review all settings** carefully
3. **Click "Create user pool"**

✅ **Expected Result**: You should see "User pool created successfully" and be on the user pool details page

**⏰ Time Check**: User pool setup should take ~20 minutes

## Step 2: Configure Advanced User Pool Settings

### 2.1 Set Up App Client Details

1. **In your new user pool**, click **"App integration"** tab
2. **Click on your app client name** (`IssueTracker-WebClient`)
3. **Scroll down to "Hosted UI"** section
4. **Edit Hosted UI settings**:
   - **Allowed callback URLs**: 
     ```
     https://localhost:3000/auth/callback
     https://your-domain.com/auth/callback
     ```
   - **Allowed sign out URLs**:
     ```
     https://localhost:3000/
     https://your-domain.com/
     ```
   - **Identity providers**: Check "Cognito user pool"
   - **OAuth 2.0 grant types**: "Authorization code grant"
   - **OpenID Connect scopes**: "OpenID", "Email", "Profile"
5. **Save changes**

### 2.2 Create User Groups for Roles

1. **Click "Groups" tab** in the left navigation
2. **Click "Create group"**

**Create Admin Group:**
- **Group name**: `Admins`
- **Description**: `Issue Tracker Administrators`
- **Precedence**: `1` (higher precedence)
- **IAM role**: Leave blank
- **Click "Create group"**

**Create Manager Group:**
- **Click "Create group"** again
- **Group name**: `Managers` 
- **Description**: `Team Managers`
- **Precedence**: `2`
- **Click "Create group"**

**Create User Group:**
- **Click "Create group"** again
- **Group name**: `Users`
- **Description**: `Standard Users`
- **Precedence**: `3` (lowest precedence)
- **Click "Create group"**

✅ **Expected Result**: You should have three user groups with proper precedence

### 2.3 Test User Pool with Console

1. **Click "Users" tab** in the left navigation
2. **Click "Create user"**
3. **Create a test admin user**:
   - **Username**: `admin@testcompany.com`
   - **Email**: `admin@testcompany.com`
   - **Temporary password**: Generate or set `TempPass123!`
   - **Phone number**: Optional
   - **Given name**: `Admin`
   - **Family name**: `User`
   - **custom:company_id**: `COMPANY001`
   - **Send an invitation to this new user?**: Check this
4. **Click "Create user"**

✅ **Expected Result**: Test user created successfully

## Step 3: Secure API Gateway with Cognito Authorization

### 3.1 Access API Gateway Console

1. 🔗 **Go to API Gateway Console**: https://console.aws.amazon.com/apigateway
2. **Click on your API**: `IssueTracker-API`
3. **Verify you can see** your existing resources (`/issues`, `/teams`)

### 3.2 Create Cognito Authorizer

1. **Click "Authorizers"** in the left navigation
2. **Click "Create New Authorizer"**
3. **Configure authorizer**:
   - **Name**: `CognitoAuthorizer`
   - **Type**: `Cognito`
   - **Cognito User Pool**: Select your `IssueTracker-UserPool`
   - **Token Source**: `Authorization`
   - **Token Validation**: Leave blank (will validate JWT automatically)
4. **Click "Create"**

### 3.3 Test the Authorizer

1. **In the Authorizers page**, click **"Test"** next to your new authorizer
2. **You'll need a valid JWT token to test** (we'll get one in the next section)
3. **For now, verify the authorizer was created successfully**

✅ **Expected Result**: Cognito authorizer created and ready to use

### 3.4 Apply Authorization to Existing Methods

**Secure GET /issues:**
1. **Click "Resources"** in left navigation
2. **Click on the `/issues` resource**
3. **Click on the "GET" method**
4. **Click "Method Request"**
5. **Edit**:
   - **Authorization**: Select `CognitoAuthorizer`
   - **OAuth Scopes**: Leave blank
6. **Save changes**

**Secure POST /issues:**
1. **Click on the "POST" method** under `/issues`
2. **Click "Method Request"**
3. **Edit**:
   - **Authorization**: Select `CognitoAuthorizer`
4. **Save changes**

**Secure Teams endpoints:**
1. **Navigate to `/teams` resource**
2. **Apply the same authorization** to GET and POST methods

### 3.5 Deploy API Changes

1. **Click "Actions"** → **"Deploy API"**
2. **Deployment stage**: Select existing stage or create "dev"
3. **Deployment description**: `Added Cognito authentication`
4. **Click "Deploy"**

✅ **Expected Result**: API deployed with Cognito authentication required

**⏰ Time Check**: API Gateway security setup should take ~25 minutes

## Step 4: Update Lambda Functions for JWT Processing

### 4.1 Access Lambda Console

1. **Go to Lambda Console**
2. **Click on** `IssueTracker-IssueManager` function

### 4.2 Add JWT Processing Library

1. **Go to the "Code" tab**
2. **We need to add JWT processing to our existing code**
3. **Update the imports section** at the top of your Lambda function:

```python
import json
import boto3
import uuid
import base64
from datetime import datetime, timezone
from decimal import Decimal
from boto3.dynamodb.conditions import Key, Attr
import os

# JWT processing (using built-in libraries)
import hmac
import hashlib
```

### 4.3 Add JWT Validation Function

**Add this function to your Lambda code** (before the lambda_handler function):

```python
def extract_user_context_from_jwt(event):
    """
    Extract user context from JWT token in API Gateway request
    This integrates perfectly with our single-table design
    """
    try:
        # Get the JWT token from API Gateway request context
        request_context = event.get('requestContext', {})
        authorizer = request_context.get('authorizer', {})
        
        # Extract claims from Cognito JWT
        claims = authorizer.get('claims', {})
        
        if not claims:
            print("No JWT claims found in request")
            return None
            
        # Extract user information from JWT
        user_context = {
            'company_id': claims.get('custom:company_id'),
            'user_email': claims.get('email'),
            'user_role': determine_user_role(claims),
            'user_name': f"{claims.get('given_name', '')} {claims.get('family_name', '')}".strip(),
            'user_groups': claims.get('cognito:groups', []),
            'sub': claims.get('sub')  # Unique user ID
        }
        
        print(f"Extracted user context: {user_context}")
        return user_context
        
    except Exception as e:
        print(f"Error extracting user context: {str(e)}")
        return None

def determine_user_role(claims):
    """
    Determine user role from Cognito groups
    Maps to our single-table role-based access control
    """
    groups = claims.get('cognito:groups', [])
    
    if 'Admins' in groups:
        return 'Admin'
    elif 'Managers' in groups:
        return 'Manager'
    elif 'Users' in groups:
        return 'User'
    else:
        return 'User'  # Default role
```

### 4.4 Update Lambda Handler to Use JWT Context

**Update your lambda_handler function** to use the JWT context:

```python
def lambda_handler(event, context):
    """
    Enhanced handler with JWT-based authentication
    Perfect integration with single-table design
    """
    
    try:
        # Extract user context from JWT token
        user_context = extract_user_context_from_jwt(event)
        
        if not user_context or not user_context.get('company_id'):
            return create_response(401, {
                'error': 'Authentication required',
                'message': 'Valid JWT token with company information required'
            })
        
        # Extract request information
        http_method = event.get('httpMethod', 'GET')
        path = event.get('path', '')
        path_parameters = event.get('pathParameters') or {}
        query_parameters = event.get('queryStringParameters') or {}
        
        print(f"Issue Management: {http_method} {path} for company {user_context['company_id']}")
        
        # Route requests with authenticated user context
        if '/issues' in path:
            return handle_issue_operations(
                http_method, path, user_context,
                path_parameters, query_parameters, event
            )
        else:
            return create_response(404, {'error': 'Endpoint not found'})
            
    except Exception as e:
        print(f"Error in issue management: {str(e)}")
        return create_response(500, {'error': 'Internal server error'})
```

### 4.5 Update Issue Operations for JWT Context

**Update your handle_issue_operations function**:

```python
def handle_issue_operations(http_method, path, user_context, path_params, query_params, event):
    """Handle issue operations with JWT-authenticated user context"""
    
    company_id = user_context['company_id']
    user_email = user_context['user_email']
    user_role = user_context['user_role']
    
    issue_id = path_params.get('issueId')
    
    if http_method == 'GET' and not issue_id:
        return list_issues(company_id, user_email, user_role)
    elif http_method == 'POST' and not issue_id:
        return create_issue(company_id, user_context, event.get('body'))
    elif http_method == 'GET' and issue_id:
        return get_issue(company_id, user_email, issue_id)
    elif http_method == 'PUT' and issue_id:
        return update_issue(company_id, user_context, issue_id, event.get('body'))
    elif http_method == 'DELETE' and issue_id:
        return delete_issue(company_id, user_email, user_role, issue_id)
    
    return create_response(404, {'error': 'Issue operation not found'})
```

### 4.6 Deploy Updated Function

1. **Click "Deploy"** in the Lambda code editor
2. **Wait for "Changes deployed"** confirmation

**Repeat the same JWT integration for your Team Management Lambda function.**

✅ **Expected Result**: Lambda functions now process JWT tokens from Cognito

**⏰ Time Check**: Lambda JWT integration should take ~30 minutes

## Step 5: Test Complete Authentication Flow

### 5.1 Get JWT Token from Cognito

1. **Go back to Cognito Console**
2. **Click on your User Pool** (`IssueTracker-UserPool`)
3. **Click "App integration" tab**
4. **Scroll down to "App clients"**
5. **Click "View Hosted UI"** link

This will open the Cognito Hosted UI where you can:
1. **Sign in** with your test user (`admin@testcompany.com`)
2. **Complete the authentication flow**
3. **Get redirected** to your callback URL with an authorization code

### 5.2 Test API with Authentication

**Option 1: Use API Gateway Test Console**

1. **Go to API Gateway Console**
2. **Navigate to your `/issues` → `GET` method**
3. **Click "TEST"**
4. **Headers**: Add `Authorization: Bearer [your-jwt-token]`
5. **Click "Test"**

**Option 2: Use curl with JWT Token**

```bash
curl -X GET \
  https://your-api-id.execute-api.region.amazonaws.com/dev/issues \
  -H "Authorization: Bearer [your-jwt-token]" \
  -H "Content-Type: application/json"
```

✅ **Expected Result**: API returns data for the authenticated user's company only

### 5.3 Verify Security Isolation

**Test Company Isolation:**
1. **Create a second test user** with different `custom:company_id`
2. **Get JWT token** for second user
3. **Make API calls** with both tokens
4. **Verify** each user only sees their company's data

✅ **Expected Result**: Perfect company isolation - users only see their own company's issues/teams

## Step 6: Monitor Security Through AWS Console

### 6.1 Set Up CloudWatch Monitoring

1. **Go to CloudWatch Console**
2. **Click "Log groups"**
3. **Find your Lambda log groups**:
   - `/aws/lambda/IssueTracker-IssueManager`
   - `/aws/lambda/IssueTracker-TeamManager`
4. **Click on each log group** to see authentication events

### 6.2 Create Security Dashboard

1. **Click "Dashboards"** in CloudWatch
2. **Click "Create dashboard"**
3. **Dashboard name**: `IssueTracker-Security-Dashboard`
4. **Add widgets**:
   - **API Gateway requests** by method
   - **Lambda function invocations**
   - **Authentication failures**
   - **Error rates by company**

### 6.3 Set Up Security Alarms

1. **Click "Alarms"** in CloudWatch
2. **Create alarm** for high authentication failure rates
3. **Create alarm** for unusual API usage patterns
4. **Set up SNS notifications** for security events

✅ **Expected Result**: Comprehensive security monitoring dashboard

## ✅ Verification Steps

### Test 1: Authentication Works
- [ ] Users can log in through Cognito Hosted UI
- [ ] JWT tokens are issued correctly
- [ ] API Gateway validates tokens automatically
- [ ] Lambda functions extract user context properly

### Test 2: Authorization Works  
- [ ] Admin users can access all company features
- [ ] Manager users have appropriate permissions
- [ ] Regular users have limited access
- [ ] Role-based filtering works correctly

### Test 3: Company Isolation
- [ ] Users only see their company's data
- [ ] Cross-company data access is impossible
- [ ] JWT tokens contain correct company information
- [ ] Database queries are company-scoped

### Test 4: Security Monitoring
- [ ] Authentication events are logged
- [ ] Failed login attempts are tracked  
- [ ] API usage is monitored by company
- [ ] Security alarms trigger appropriately

### Test 5: Performance
- [ ] Authentication adds minimal latency
- [ ] Single-table queries remain fast
- [ ] JWT processing is efficient
- [ ] No performance degradation with security

## 🎯 What We Accomplished

🎉 **Outstanding work!** You've built enterprise-grade authentication:

- ✅ **OAuth2 Authentication** with Amazon Cognito through console only
- ✅ **JWT Token Validation** integrated with Lambda functions  
- ✅ **Role-Based Access Control** (Admin/Manager/User hierarchy)
- ✅ **Perfect Company Isolation** with JWT-embedded company context
- ✅ **API Gateway Security** with automatic token validation
- ✅ **Security Monitoring** through CloudWatch dashboards
- ✅ **Scalable Authentication** that grows with your SaaS
- ✅ **Console-First Management** for easy security administration

## 🚀 Security Architecture Benefits

**🔐 Enterprise Security**:
- Industry-standard OAuth2 flows
- JWT tokens for stateless authentication
- Multi-factor authentication support
- Comprehensive audit trails

**⚡ Performance Benefits**:
- 3-5x faster than traditional multi-system auth
- Single JWT contains all user context
- No additional database queries for permissions
- Perfect integration with single-table design

**💰 Cost Efficiency**:
- 80% reduction in authentication complexity
- No separate user management infrastructure
- Built-in AWS security features
- Reduced development and maintenance costs

**🎯 Developer Experience**:
- Visual security management through AWS Console
- Built-in testing tools
- Automatic token validation
- Easy role and permission management

## 🔜 What's Next?

In **Part 9: Advanced Multi-Tenant Logic**, we'll:

- Implement advanced company data partitioning strategies
- Add subscription tier-based feature controls
- Create company-specific configuration management
- Build advanced analytics and reporting per tenant
- Implement cross-company admin capabilities (for SaaS operators)
- Add company onboarding and provisioning workflows
- Set up automated company data backup and recovery

This will complete your multi-tenant architecture with sophisticated company management capabilities!

**Ready to build advanced multi-tenant features?** Head to [Part 9: Advanced Multi-Tenant Logic](./09.%20Advanced%20Multi-Tenant%20Logic.md)!

---

## 📝 Important Information to Save

**Cognito User Pool Details**:
- ✅ **User Pool Name**: `IssueTracker-UserPool`
- ✅ **User Pool ID**: `_________________` (copy from console)
- ✅ **App Client Name**: `IssueTracker-WebClient`
- ✅ **App Client ID**: `_________________` (copy from console)
- ✅ **Hosted UI Domain**: `issuetracker-auth-[your-string].auth.[region].amazoncognito.com`

**User Groups**:
- **Admins** (Precedence: 1) - Full company management
- **Managers** (Precedence: 2) - Team and issue management  
- **Users** (Precedence: 3) - Standard issue access

**API Gateway Security**:
- ✅ **Authorizer Name**: `CognitoAuthorizer`
- ✅ **Token Source**: Authorization header
- ✅ **Secured Endpoints**: `/issues`, `/teams` (all methods)

**JWT Token Claims Used**:
- `custom:company_id` - Company isolation
- `email` - User identification  
- `cognito:groups` - Role determination
- `given_name`, `family_name` - User display name
- `sub` - Unique user identifier

**Security Monitoring**:
- CloudWatch Log Groups: `/aws/lambda/IssueTracker-*`
- Security Dashboard: `IssueTracker-Security-Dashboard`
- Authentication failure alarms configured

**Test Credentials** (change in production):
- Test Admin: `admin@testcompany.com`
- Company ID: `COMPANY001`
- Temporary Password: `TempPass123!`

_💡 Pro Tip: Test the authentication flow with different user roles to verify the role-based access control works correctly. Each role should have appropriate permissions!_

_🔐 Security Note: Always use strong passwords and enable MFA for production user accounts. The single-table design with JWT authentication provides both security and performance benefits._